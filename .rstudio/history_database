0:library(ggplot2)
0:library(CountClust)
0:dirname <- "/home/genomics/workshop_materials/scrna/pbmc3k/"
0:dirname <- "/Users/kgosik/Documents/data/cellranger/"
0:counts_matrix_filename = paste0(dirname, "pbmc3k/filtered_gene_bc_matrices/hg19/")
0:counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
0:### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
0:seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_PBMC")
0:# The number of genes and UMIs (nFeature_RNA nCount_RNA) are automatically calculated
0:# for every object by Seurat.  For non-UMI data, nCount_RNA represents the sum of
0:# the non-normalized values within a cell We calculate the percentage of
0:# mitochondrial genes here and store it in percent.mito using AddMetaData.
0:# We use object@raw.data since this represents non-transformed and
0:# non-log-normalized counts The % of UMI mapping to MT-genes is a common
0:# scRNA-seq QC metric.
0:seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
0:##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
0:# We filter out cells that have unique gene counts over 2,500 or less than
0:# 200 Note that low.thresholds and high.thresholds are used to define a
0:# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
0:# threshold.
0:seurat <- SubsetData(object = seurat,
0:subset.names = c("nFeature_RNA", "percent.mt"),
0:low.thresholds = c(200, -Inf),
0:high.thresholds = c(2500, 0.1))
0:seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
0:# Read in a list of cell cycle markers, from Tirosh et al, 2015.
0:# We can segregate this list into markers of G2/M phase and markers of S phase.
0:cc.genes <- readLines(paste0(dirname, "regev_lab_cell_cycle_genes.txt"))
0:s.genes <- cc.genes[1:43]
0:s.genes <- s.genes[s.genes %in% rownames(seurat)] # genes in dataset
0:g2m.genes <- cc.genes[44:97]
0:g2m.genes <- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset
0:seurat <- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
0:seurat <- FindVariableFeatures(object = seurat,
0:mean.function = ExpMean,
0:dispersion.function = LogVMR)
0:seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
0:## randomly making a batch id data.frame
0:batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
0:batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
0:stringsAsFactors = FALSE)
0:row.names(batch_ids) <- row.names(seurat@meta.data)
0:seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
0:seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
0:seurat <- RunPCA(object = seurat,
0:# features = seurat@assays$RNA@var.features,
0:do.print = TRUE,
0:pcs.print = 1:5,
0:genes.print = 5)
0:DimPlot(seurat, reduction = "pca")
0:# ProjectDim scores each gene in the dataset (including genes not included
0:# in the PCA) based on their correlation with the calculated components.
0:# Though we don't use this further here, it can be used to identify markers
0:# that are strongly correlated with cellular heterogeneity, but may not have
0:# passed through variable gene selection.  The results of the projected PCA
0:# can be explored by setting use.full=T in the functions above
0:seurat <- ProjectDim(object = seurat, reduction = "pca")
0:DimHeatmap(object = seurat,
0:dims = 1:6,
0:cells = 50,
0:reduction = "pca",
0:balanced = TRUE)
0:DimHeatmap()
0:ElbowPlot(object = seurat, ndims = 10, reduction = "pca")
0:# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
0:# using the same graph but with a different resolution value (see docs for
0:# full details)
0:set.seed(2020)
0:seurat <- FindNeighbors(object = seurat, dims = 1:10)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.5)
0:set.seed(2020)
0:seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
0:# note that you can set do.label=T to help label individual clusters
0:DimPlot(object = seurat, reduction = "tsne")
0:# find all markers of cluster 1 using default parameters
0:cluster1.markers <- FindMarkers(object = seurat, ident.1 = 1, min.pct = 0.25)
0:head(cluster1.markers)
0:# find all markers distinguishing cluster 5 from clusters 0 and 1
0:cluster5.markers <- FindMarkers(object = seurat,
0:ident.1 = 5, ident.2 = c(0, 1),
0:min.pct = ??
0:test.use = ??,
0:cluster2.markers <- FindMarkers(object = seurat,
0:ident.1 = 2,
0:thresh.use = 0.25,
0:test.use = "roc",
0:only.pos = TRUE)
0:head(cluster2.markers)
0:VlnPlot(object = seurat, features = c("MS4A1", "CD79A"))
0:# you can plot raw UMI counts as well
0:VlnPlot(object = seurat,
0:features = c("NKG7", "PF4"),
0:log = TRUE)
0:# find markers for every cluster compared to all remaining cells, report
0:# only the positive ones
0:pbmc.markers <- FindAllMarkers(object = seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
0:pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
0:FeaturePlot(object = seurat,
0:features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A"),
0:cols = c("grey", "blue"),
0:reduction = "tsne")
0:top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
0:# setting slim.col.label to TRUE will print just the cluster IDS instead of
0:# every cell name
0:DoHeatmap(object = seurat, features = top10$gene, label = TRUE)
0:new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "B", "Naive CD4 T", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
0:names(x = new.cluster.ids) <- levels(x = seurat)
0:seurat <- RenameIdents(object = seurat, new.cluster.ids)
0:DimPlot(object = seurat, reduction = 'tsne', label = TRUE, pt.size = 0.5) + NoLegend()
0:# First lets stash our identities for later
0:seurat <- StashIdent(object = seurat, save.name = "ClusterNames_0.6")
0:# Note that if you set save.snn=T above, you don't need to recalculate the
0:# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.8)
0:set.seed(2020)
0:## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
0:## = reduction.type, : Build parameters exactly match those of already
0:## computed and stored SNN. To force recalculation, set force.recalc to TRUE.
0:# Demonstration of how to plot two tSNE plots side by side, and how to color
0:# points based on different criteria
0:plot1 <- DimPlot(object = seurat,
0:reduction= "tsne",
0:label = TRUE) + NoLegend()
0:plot2 <- DimPlot(object = seurat,
0:reduction = "tsne",
0:group.by = "ClusterNames_0.6",
0:label = TRUE) + NoLegend()
0:CombinePlots(list(plot1, plot2))
0:# Find discriminating markers
0:tcell.markers <- FindMarkers(object = seurat, ident.1 = 0, ident.2 = 1)
0:# Most of the markers tend to be expressed in C1 (i.e. S100A4). However, we
0:# can see that CCR7 is upregulated in C0, strongly indicating that we can
0:# differentiate memory from naive CD4 cells.  cols demarcates the color
0:# palette from low to high expression
0:FeaturePlot(object = seurat, features = c("S100A4", "CCR7"), cols = c("green", "blue"))
0:## Differential expression using DESeq2
0:FindMarkers(object = seurat, ident.1 = 0, ident.2 = 1, test.use = "DESeq2")
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:Seurat::cc.genes
0:?FindCluster
0:?FindClusters
0:# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
0:# using the same graph but with a different resolution value (see docs for
0:# full details)
0:set.seed(2020)
0:seurat <- FindNeighbors(object = seurat, dims = 1:10)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.5,
0:random.seed = 2020)
0:set.seed(2020)
0:seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
0:# note that you can set do.label=T to help label individual clusters
0:DimPlot(object = seurat, reduction = "tsne")
0:cluster2.markers <- FindMarkers(object = seurat,
0:ident.1 = 2,
0:thresh.use = 0.25,
0:test.use = "roc",
0:only.pos = TRUE)
0:head(cluster2.markers)
0:VlnPlot(object = seurat, features = c("MS4A1", "CD79A"))
0:rm(list=ls(
0:))
0:library(Seurat)
0:library(dplyr)
0:library(ggplot2)
0:library(CountClust)
0:dirname <- "/home/genomics/workshop_materials/scrna/"
0:## dirname <- "/Users/kgosik/Documents/data/cellranger/"
0:counts_matrix_filename = paste0(dirname, "pbmc3k/filtered_gene_bc_matrices/hg19/")
0:counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
0:dirname <- "/Users/kgosik/Documents/data/cellranger/"
0:## dirname <- "/Users/kgosik/Documents/data/cellranger/"
0:counts_matrix_filename = paste0(dirname, "pbmc3k/filtered_gene_bc_matrices/hg19/")
0:counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
0:### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
0:seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_PBMC")
0:# The number of genes and UMIs (nFeature_RNA nCount_RNA) are automatically calculated
0:# for every object by Seurat.  For non-UMI data, nCount_RNA represents the sum of
0:# the non-normalized values within a cell We calculate the percentage of
0:# mitochondrial genes here and store it in percent.mito using AddMetaData.
0:# We use object@raw.data since this represents non-transformed and
0:# non-log-normalized counts The % of UMI mapping to MT-genes is a common
0:# scRNA-seq QC metric.
0:seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
0:##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
0:# FeatureScatter is typically used to visualize gene-gene relationships, but can
0:# be used for anything calculated by the object, i.e. columns in
0:# object@meta.data, PC scores etc.  Since there is a rare subset of cells
0:# with an outlier level of high mitochondrial percentage and also low UMI
0:# content, we filter these as well
0:par(mfrow = c(1, 2))
0:FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
0:FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
0:# We filter out cells that have unique gene counts over 2,500 or less than
0:# 200 Note that low.thresholds and high.thresholds are used to define a
0:# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
0:# threshold.
0:seurat <- SubsetData(object = seurat,
0:subset.names = c("nFeature_RNA", "percent.mt"),
0:low.thresholds = c(200, -Inf),
0:high.thresholds = c(2500, 0.1))
0:seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
0:# Read in a list of cell cycle markers, from Tirosh et al, 2015.
0:# We can segregate this list into markers of G2/M phase and markers of S phase.
0:s.genes <- Seurat::cc.genes$s.genes
0:s.genes <- s.genes[s.genes %in% rownames(seurat)] # genes in dataset
0:g2m.genes <- Seurat::cc.genes$g2m.genes
0:g2m.genes <- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset
0:seurat <- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
0:seurat <- FindVariableFeatures(object = seurat,
0:mean.function = ExpMean,
0:dispersion.function = LogVMR)
0:## randomly making a batch id data.frame
0:batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
0:batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
0:stringsAsFactors = FALSE)
0:row.names(batch_ids) <- row.names(seurat@meta.data)
0:seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
0:seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
0:seurat <- RunPCA(object = seurat,
0:# features = seurat@assays$RNA@var.features,
0:do.print = TRUE,
0:pcs.print = 1:5,
0:genes.print = 5)
0:DimPlot(seurat, reduction = "pca")
0:# ProjectDim scores each gene in the dataset (including genes not included
0:# in the PCA) based on their correlation with the calculated components.
0:# Though we don't use this further here, it can be used to identify markers
0:# that are strongly correlated with cellular heterogeneity, but may not have
0:# passed through variable gene selection.  The results of the projected PCA
0:# can be explored by setting use.full=T in the functions above
0:seurat <- ProjectDim(object = seurat, reduction = "pca")
0:DimHeatmap(object = seurat,
0:dims = 1:6,
0:cells = 50,
0:reduction = "pca",
0:balanced = TRUE)
0:PCASigGenes(object = seurat, pcs.use = 1:2, pval.cut = 0.1)
0:ElbowPlot(object = seurat, ndims = 10, reduction = "pca")
0:# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
0:# using the same graph but with a different resolution value (see docs for
0:# full details)
0:set.seed(2020)
0:seurat <- FindNeighbors(object = seurat, dims = 1:10)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.5,
0:random.seed = 2020)
0:set.seed(2020)
0:seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
0:# note that you can set do.label=T to help label individual clusters
0:DimPlot(object = seurat, reduction = "tsne")
0:# find all markers of cluster 1 using default parameters
0:cluster1.markers <- FindMarkers(object = seurat, ident.1 = 1, min.pct = 0.25)
0:head(cluster1.markers)
0:cluster3.markers <- FindMarkers(object = seurat,
0:ident.1 = 2,
0:thresh.use = 0.25,
0:test.use = "roc",
0:only.pos = TRUE)
0:head(cluster3.markers)
0:VlnPlot(object = seurat, features = c("MS4A1", "CD79A"))
0:# you can plot raw UMI counts as well
0:VlnPlot(object = seurat,
0:features = c("NKG7", "PF4"),
0:log = TRUE)
0:new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
0:names(x = new.cluster.ids) <- levels(x = seurat)
0:seurat <- RenameIdents(object = seurat, new.cluster.ids)
0:DimPlot(object = seurat, reduction = 'tsne', label = TRUE, pt.size = 0.5) + NoLegend()
0:# First lets stash our identities for later
0:seurat <- StashIdent(object = seurat, save.name = "ClusterNames_0.6")
0:# Note that if you set save.snn=T above, you don't need to recalculate the
0:# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.8)
0:set.seed(2020)
0:## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
0:## = reduction.type, : Build parameters exactly match those of already
0:## computed and stored SNN. To force recalculation, set force.recalc to TRUE.
0:# Demonstration of how to plot two tSNE plots side by side, and how to color
0:# points based on different criteria
0:plot1 <- DimPlot(object = seurat,
0:reduction= "tsne",
0:label = TRUE) + NoLegend()
0:plot2 <- DimPlot(object = seurat,
0:reduction = "tsne",
0:group.by = "ClusterNames_0.6",
0:label = TRUE) + NoLegend()
0:CombinePlots(list(plot1, plot2))
0:bookdown
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:rm(list=ls())
0:rm(list=ls())
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:?FindNeighbors
0:knitr::opts_knit$set(progress=FALSE, verbose=FALSE)
0:library(Seurat)
0:library(dplyr)
0:library(Matrix)
0:paste0(dirname, "housekeepers.txt")
0:bookdown::render_book('.')
0:rm(list=ls())
0:bookdown::render_book('.')
0:# Read in a list of cell cycle markers, from Tirosh et al, 2015.
0:# We can segregate this list into markers of G2/M phase and markers of S phase.
0:s.genes <- Seurat::cc.genes$s.genes
0:s.genes <- s.genes[s.genes %in% rownames(seurat)] # genes in dataset
0:g2m.genes <- Seurat::cc.genes$g2m.genes
0:g2m.genes <- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset
0:seurat <- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
0:seurat <- FindVariableFeatures(object = seurat,
0:mean.function = ExpMean,
0:dispersion.function = LogVMR)
0:rm(list=ls())
0:knitr::opts_knit$set(progress=FALSE, verbose=FALSE)
0:library(Seurat)
0:library(dplyr)
0:library(ggplot2)
0:library(CountClust)
0:## dirname <- "/home/genomics/workshop_materials/scrna/"
0:dirname <- "/Users/kgosik/Documents/data/cellranger/"
0:counts_matrix_filename = paste0(dirname, "pbmc3k/filtered_gene_bc_matrices/hg19/")
0:counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
0:### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
0:seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_PBMC")
0:# The number of genes and UMIs (nFeature_RNA nCount_RNA) are automatically calculated
0:# for every object by Seurat.  For non-UMI data, nCount_RNA represents the sum of
0:# the non-normalized values within a cell We calculate the percentage of
0:# mitochondrial genes here and store it in percent.mito using AddMetaData.
0:# We use object@raw.data since this represents non-transformed and
0:# non-log-normalized counts The % of UMI mapping to MT-genes is a common
0:# scRNA-seq QC metric.
0:seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
0:##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
0:# FeatureScatter is typically used to visualize gene-gene relationships, but can
0:# be used for anything calculated by the object, i.e. columns in
0:# object@meta.data, PC scores etc.  Since there is a rare subset of cells
0:# with an outlier level of high mitochondrial percentage and also low UMI
0:# content, we filter these as well
0:par(mfrow = c(1, 2))
0:FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
0:FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
0:# We filter out cells that have unique gene counts over 2,500 or less than
0:# 200 Note that low.thresholds and high.thresholds are used to define a
0:# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
0:# threshold.
0:seurat <- SubsetData(object = seurat,
0:subset.names = c("nFeature_RNA", "percent.mt"),
0:low.thresholds = c(200, -Inf),
0:high.thresholds = c(2500, 0.1))
0:seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
0:# Read in a list of cell cycle markers, from Tirosh et al, 2015.
0:# We can segregate this list into markers of G2/M phase and markers of S phase.
0:s.genes <- Seurat::cc.genes$s.genes
0:s.genes <- s.genes[s.genes %in% rownames(seurat)] # genes in dataset
0:g2m.genes <- Seurat::cc.genes$g2m.genes
0:g2m.genes <- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset
0:seurat <- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
0:seurat <- FindVariableFeatures(object = seurat,
0:mean.function = ExpMean,
0:dispersion.function = LogVMR)
0:seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
0:## randomly making a batch id data.frame
0:batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
0:batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
0:stringsAsFactors = FALSE)
0:row.names(batch_ids) <- row.names(seurat@meta.data)
0:seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
0:seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
0:seurat <- RunPCA(object = seurat,
0:# features = seurat@assays$RNA@var.features,
0:do.print = TRUE,
0:pcs.print = 1:5,
0:genes.print = 5)
0:# ProjectDim scores each gene in the dataset (including genes not included
0:# in the PCA) based on their correlation with the calculated components.
0:# Though we don't use this further here, it can be used to identify markers
0:# that are strongly correlated with cellular heterogeneity, but may not have
0:# passed through variable gene selection.  The results of the projected PCA
0:# can be explored by setting use.full=T in the functions above
0:seurat <- ProjectDim(object = seurat, reduction = "pca")
0:# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
0:# using the same graph but with a different resolution value (see docs for
0:# full details)
0:set.seed(2020)
0:seurat <- FindNeighbors(object = seurat, dims = 1:10)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.5,
0:random.seed = 2020)
0:set.seed(2020)
0:seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
0:# note that you can set do.label=T to help label individual clusters
0:DimPlot(object = seurat, reduction = "tsne")
0:cluster3.markers <- FindMarkers(object = seurat,
0:ident.1 = 3,
0:thresh.use = 0.25,
0:test.use = "roc",
0:only.pos = TRUE)
0:head(cluster3.markers)
0:VlnPlot(object = seurat, features = c("MS4A1", "CD79A"))
0:new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
0:names(x = new.cluster.ids) <- levels(x = seurat)
0:seurat <- RenameIdents(object = seurat, new.cluster.ids)
0:DimPlot(object = seurat, reduction = 'tsne', label = TRUE, pt.size = 0.5) + NoLegend()
0:names(x = new.cluster.ids) <- levels(x = seurat)
0:# First lets stash our identities for later
0:seurat <- StashIdent(object = seurat, save.name = "ClusterNames_0.6")
0:# Note that if you set save.snn=T above, you don't need to recalculate the
0:# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
0:seurat <- FindClusters(object = seurat,
0:reduction = "pca",
0:dims = 1:10,
0:resolution = 0.8)
0:bookdown::render_book('.')
0:row.names(batch_ids) <- row.names(seurat@meta.data)
0:bookdown::render_book('.')
0:rownames(seurat)
0:# Read in a list of cell cycle markers, from Tirosh et al, 2015.
0:# We can segregate this list into markers of G2/M phase and markers of S phase.
0:s.genes <- Seurat::cc.genes$s.genes
0:s.genes <- s.genes[s.genes %in% rownames(seurat)] # genes in dataset
0:g2m.genes <- Seurat::cc.genes$g2m.genes
0:g2m.genes <- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset
0:seurat <- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
0:rm(list=ls())
0:set.seed(2020)
0:## Preprocessing Steps
0:pbmc_small <- NormalizeData(object = pbmc_small, normalization.method = "LogNormalize", scale.factor = 10000)
0:pbmc_small <- RunPCA(object = pbmc_small)
0:pbmc_small <- FindClusters(object = pbmc_small,
0:reduction = "pca",
0:dims.use = 1:10,
0:resolution = 1,
0:print.output = 0)
0:pbmc_counts <- as.matrix(pbmc_small@assays$RNA@data)
0:pbmc_meta <- pbmc_small@meta.data
0:gene_names <- rownames(pbmc_counts)
0:pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
0:omega <- data.frame(pbmc_FitGoM$fit$omega)
0:annotation <- data.frame(sample_id = rownames(omega),
0:tissue_label = paste0("cluster", pbmc_small@active.ident))
0:colnames(omega) <- paste0("topic", 1:4)
0:rownames(omega) <- annotation$sample_id;
0:StructureGGplot(omega = omega,
0:annotation = annotation,
0:palette = RColorBrewer::brewer.pal(4, "Dark2"),
0:yaxis_label = "Cells",
0:order_sample = TRUE,
0:axis_tick = list(axis_ticks_length = .1,
0:axis_ticks_lwd_y = .1,
0:axis_ticks_lwd_x = .1,
0:axis_label_size = 7,
0:axis_label_face = "bold"))
0:# ## Add Topic Scores to Meta Data Part of the Seurat Object
0:pbmc_small <- AddMetaData(pbmc_small, omega)
0:pbmc_small@meta.data %>%
0:group_by(RNA_snn_res.1) %>%
0:summarise(topic1 = mean(topic1),
0:topic2 = mean(topic2),
0:topic3 = mean(topic3),
0:topic4 = mean(topic4))
0:## ggplot object, you can add layers
0:p1 <- DimPlot(pbmc_small, reduction = "tsne") + labs(title = "Resolution 1") ## return ggplot object
0:p1
0:p2 <- FeaturePlot(object = pbmc_small,
0:features = c("topic1", "topic2", "topic3", "topic4"),
0:cols = c("grey", "blue"),
0:reduction = "tsne") ## return ggplot object
0:p2
0:out_table <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
0:theta_mat <- pbmc_FitGoM$fit$theta
0:top_features <- ExtractTopFeatures(theta_mat,
0:top_features=100,
0:method="poisson",
0:options="min")
0:gene_list <- do.call(rbind,
0:lapply(1:dim(top_features$indices)[1],
0:function(x) gene_names[top_features$indices[x,]]))
0:out_table <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
0:rownames(out_table) <- paste("Topic", c(1:4))
0:rownames(out_table)
0:out_table
0:gene_list
0:lapply(1:5, function(i) toString(gene_list[,i])
0:)
0:out_table <- do.call(rbind, lapply(1:4, function(i) toString(gene_list[i,1:5])))
0:rownames(out_table) <- paste("Topic", c(1:4))
0:out_table
0:bookdown::render_book('.')
0:bookdown::render_book('.')
0:getwd()
