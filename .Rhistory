knitr::kable()
tmp <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
rownames(tmp) <- paste("Cluster", c(1:5))
tmp %>%
knitr::kable("html") %>%
knitr::kable_styling()
??kable_styoing
tmp <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
rownames(tmp) <- paste("Cluster", c(1:5))
tmp %>%
knitr::kable("html")
p2
p2$data
p2$layers
p2$plot_env
p2
p2 <- FeaturePlot(object = pbmc_small,
features = c("topic1", "topic2", "topic3", "topic4"),
cols = c("grey", "blue"),
reduction = "tsne") ## return ggplot object
p2
p2
?FeaturePlot
tmp
p2 <- FeaturePlot(object = pbmc_small,
features = c("topic1", "topic2", "topic3", "topic4"),
cols = c("grey", "blue"),
reduction = "tsne") ## return ggplot object
p2
## batch_ids <- read.csv('file_with_batch_ids.csv')
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
## batch_ids <- read.csv('file_with_batch_ids.csv')
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = "batch_id")
seurat@meta.data
batch_ids
dim(seurat@meta.data)
dim(batch_ids)
?AddMetaData
merge(batch_ids, seurat@meta.data)
?merge
?merge
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
#row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = "batch_id")
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
#row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)#"batch_id")
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat@meta.data
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
seurat@meta.data
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
#row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)#"batch_id")
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat@meta.data
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)#"batch_id")
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat@meta.data
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)#"batch_id")
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
# ProjectPCA scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
seurat <- Project(object = seurat, reduction = "pca")
?Seurat::Project
?ProjectDim
# ProjectDim scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
seurat <- ProjectDim(object = seurat, reduction = "pca")
DimPlot(seurat, reduction = "pca")
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
DimPlot(seurat, reduction = "pca")
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
seurat <- RunICA(seurat, nics = 5)
DimPlot(seurat, reduction = "pca")
DimPlot(seurat, reduction = "ica")
# ProjectDim scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
seurat <- ProjectDim(object = seurat, reduction = "pca")
DimHeatmap(object = seurat,
dims = 1:10,
cells = 50,
reduction = "pca",
do.balanced = TRUE,
label.columns = FALSE)
?DimHear
?DimHeatmap
DimHeatmap(object = seurat,
dims = 1:10,
cells = 50,
reduction = "pca",
balanced = TRUE,
label.columns = FALSE)
DimHeatmap(object = seurat,
dims = 1:10,
cells = 50,
reduction = "pca",
balanced = TRUE)
ElbowPlot(object = seurat, ndims = 10, reduction = "pca")
ElbowPlot(object = seurat, ndims = 10, reduction = "pca")
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
?FindClusters
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1,
print.output = 0)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
ndims = 1:10,
resolution = 1,
print.output = 0)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
ndims = 1:10,
resolution = 1)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
ndim = 1:10,
resolution = 1)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
seurat <- FindClusters(object = seurat,
#reduction = "pca",
dims = 1:10,
resolution = 1)
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
seurat <- RunICA(seurat, nics = 5)
DimPlot(seurat, reduction = "pca")
DimPlot(seurat, reduction = "ica")
# ProjectDim scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
seurat <- ProjectDim(object = seurat, reduction = "pca")
DimHeatmap(object = seurat,
dims = 1:10,
cells = 50,
reduction = "pca",
balanced = TRUE)
ElbowPlot(object = seurat, ndims = 10, reduction = "pca")
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
pbmc <- FindNeighbors(object = pbmc, dims = 1:10)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
set.seed(runif(100))
seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = seurat)
# find all markers of cluster 1
cluster1.markers <- FindMarkers(object = seurat, ident.1 = 1, min.pct = 0.25)
print(x = head(x = cluster1.markers, n = 5))
# find all markers distinguishing cluster 2 from clusters 0 and 1
cluster2.markers <- FindMarkers(object = seurat, ident.1 = 2, ident.2 = c(0, 1), min.pct = 0.25)
print(x = head(x = cluster5.markers, n = 5))
# find all markers distinguishing cluster 2 from clusters 0 and 1
cluster5.markers <- FindMarkers(object = seurat, ident.1 = 5, ident.2 = c(0, 1), min.pct = 0.25)
print(x = head(x = cluster5.markers, n = 5))
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
