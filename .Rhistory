axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
# ## Add Topic Scores to Meta Data Part of the Seurat Object
# pbmc_small@meta.data <- cbind(pbmc_meta, omega)
omega
AddMetaData(pbmc_small, omega)
AddMetaData(pbmc_small, omega, col.name = NULL)
omega
pbmc_small@meta.data
AddMetaData(pbmc_small, omega, col.name = NULL)
?AddMetaData
str(omega)
data.frame(omega)
set.seed(2019)
## Preprocessing Steps
pbmc_small <- NormalizeData(object = pbmc_small, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc_small <- RunPCA(object = pbmc_small)
pbmc_small <- FindClusters(object = pbmc_small,
reduction = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
pbmc_counts <- as.matrix(pbmc_small@assays$RNA@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- data.frame(pbmc_FitGoM$fit$omega)
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
# ## Add Topic Scores to Meta Data Part of the Seurat Object
# pbmc_small@meta.data <- cbind(pbmc_meta, omega)
AddMetaData(pbmc_small, omega)
pbmc_small <- AddMetaData(pbmc_small, omega)
pbmc_small@meta.data
pbmc_small@meta.data %>%
group_by(RNA_snn_res.1) %>%
summarise(topic1 = mean(topic1),
topic2 = mean(topic2),
topic3 = mean(topic3),
topic4 = mean(topic4))
## ggplot object, you can add layers
p1 <- DimPlot(pbmc_small, reduction = "tsne") + labs(title = "Resolution 1") ## return ggplot object
p1
p2 <- FeaturePlot(object = pbmc_small,
features = c("topic1", "topic2", "topic3", "topic4"),
cols = c("grey", "blue"),
reduction = "tsne") ## return ggplot object
p2
CombinePlots(list(p1, p2))
theta_mat <- pbmc_FitGoM$fit$theta
top_features <- ExtractTopFeatures(theta_mat,
top_features=100,
method="poisson",
options="min")
gene_list <- do.call(rbind,
lapply(1:dim(top_features$indices)[1],
function(x) gene_names[top_features$indices[x,]]))
tmp <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
rownames(tmp) <- paste("Cluster", c(1:5))
tmp %>%
knitr::kable("html")
out_table <- do.call(rbind, lapply(1:5, function(i) toString(gene_list[,i])))
rownames(out_table) <- paste("Cluster", c(1:5))
out_table
test.pbmc <- SubsetData(object = pbmc_small, cells.use = pbmc_small@cell.names[1:10])
train.pbmc <- SubsetData(object = pbmc_small, cells.use = pbmc_small@cell.names[11:80])
predicted.classes <- ClassifyCells(
object = train.pbmc,
training.classes = train.pbmc@ident,
new.data = test.pbmc@data
)
?SplitObject
?sample
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
obj.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.list[["train"]]
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.list[["train"]]
pmbc_small <- GetCentroids(pbmc_small, cells.use=pbmc_small@cell.names)
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
?FeatureScatter
seurat@meta.data
bookdown::render_book('.')
VariableFeaturePlot(seurat)
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
library(qtlcharts)
# simulate some data
n.ind <- 500
n.gene <- 10000
expr <- matrix(rnorm(n.ind * n.gene, (1:n.ind)/n.ind*3), ncol=n.gene)
dimnames(expr) <- list(paste0("ind", 1:n.ind),
paste0("gene", 1:n.gene))
# generate the plot
iboxplot(expr)
devtools::install_github("kbroman/qtlcharts")
library(qtlcharts)
# simulate some data
n.ind <- 500
n.gene <- 10000
expr <- matrix(rnorm(n.ind * n.gene, (1:n.ind)/n.ind*3), ncol=n.gene)
dimnames(expr) <- list(paste0("ind", 1:n.ind),
paste0("gene", 1:n.gene))
# generate the plot
iboxplot(expr)
bookdown::render_book('.')
?FindIntegrationAnchors
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
# Find Anchors
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:30)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
# Find Anchors
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:10)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
# Find Anchors
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:5)
SplitObject(pbmc_small, split.by = "group")
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
# Find Anchors
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:5)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(pbmc_small@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
pbmc_small <- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
# Find Anchors
pbmc_small.list <- SplitObject(pbmc_small, split.by = "group")
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:5, max.features = 5)
pbmc_small.anchors <- FindIntegrationAnchors(object.list = pbmc_small.list, dims = 1:5, k.anchor = 5)
rm(list=ls())
gc()
library(Seurat)
library(dplyr)
library(ggplot2)
library(CountClust)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
counts <- counts[,1:1000]
### seurat<-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = "10X_NSCLC")
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
##VlnPlot(object = seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(object = seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
## randomly making a batch id data.frame
batch_ids <- data.frame(barcode = rownames(seurat@meta.data),
batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE),
stringsAsFactors = FALSE)
row.names(batch_ids) <- row.names(seurat@meta.data)
seurat <- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL)
seurat <- ScaleData(object = seurat, vars.to.regress = 'batch_id')
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
# ProjectDim scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
seurat <- ProjectDim(object = seurat, reduction = "pca")
DimHeatmap(object = seurat,
dims = 1:10,
cells = 50,
reduction = "pca",
balanced = TRUE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
set.seed(runif(100))
seurat <- RunTSNE(seurat, reduction.use = "pca", dims.use = 1:10, perplexity=10)
# note that you can set do.label=T to help label individual clusters
DimPlot(object = seurat, reduction = "tsne")
set.seed(runif(100))
seurat <- RunUMAP(seurat, dims = 1:10, perplexity=10)
# note that you can set do.label=T to help label individual clusters
DimPlot(object = seurat, reduction = "umap")
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
names(x = new.cluster.ids) <- levels(x = seurat)
seurat <- RenameIdents(object = seurat, new.cluster.ids)
DimPlot(object = seurat, reduction = 'umap', label = TRUE, pt.size = 0.5) + NoLegend()
# First lets stash our identities for later
seurat <- StashIdent(object = seurat, save.name = "ClusterNames_0.6")
# Note that if you set save.snn=T above, you don't need to recalculate the
# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 0.8)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(seurat@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(pbmc_small)
seurat <- AddMetaData(object = seurat, metadata = groups, col.name = "group")
# Find Anchors
seurat.list <- SplitObject(seurat, split.by = "group")
seurat@meta.data
colnames(seurat)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(seurat@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(seurat)
seurat <- AddMetaData(object = seurat, metadata = groups, col.name = )
seurat <- AddMetaData(object = seurat, metadata = groups, col.name = "group")
seurat@meta.data
# Find Anchors
seurat.list <- SplitObject(seurat, split.by = "group")
seurat.anchors <- FindIntegrationAnchors(object.list = seurat.list, dims = 1:20, k.anchor = 5)
seurat.query <- seurat.list[["train"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated, query = seurat.query,
dims = 1:30)
seurat.integrated <- IntegrateData(anchorset = seurat.anchors, dims = 1:30)
seurat.query <- seurat.list[["train"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated,
query = seurat.query,
dims = 1:30)
predictions <- TransferData(anchorset = seurat.anchors, refdata = seurat.integrated$celltype, dims = 1:30)
seurat.integrated$
j
seurat.integrated$ClusterNames_0.6
predictions <- TransferData(anchorset = seurat.anchors,
refdata = seurat.integrated$ClusterNames_0.6,
dims = 1:30)
predictions
table(groups)
dim(predictions)
seurat.query <- seurat.list[["test"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated,
query = seurat.query,
dims = 1:30)
predictions <- TransferData(anchorset = seurat.anchors,
refdata = seurat.integrated$ClusterNames_0.6,
dims = 1:30)
predictions
seurat.query <- AddMetaData(seurat.query, metadata = predictions)
seurat.query
seurat.query@meta.data
table(seurat.query@meta.data$ClusterNames_0.6, seurat.query@meta.data$predicted.id)
get.centroid
Seurat::get.centroid
bookdown::render_book('.')
seurat.anchors <- FindIntegrationAnchors(object.list = seurat.list, dims = 1:30)
bookdown::render_book('.')
seurat.anchors <- FindIntegrationAnchors(object.list = seurat.list, dims = 1:30)
seurat.integrated <- IntegrateData(anchorset = seurat.anchors, dims = 1:30)
seurat.query <- seurat.list[["test"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated,
query = seurat.query,
dims = 1:30)
# Assign the test object a three level attribute
groups <- sample(c("train", "test"), size = NROW(seurat@meta.data), replace = TRUE, prob = c(0.8, 0.2))
names(groups) <- colnames(seurat)
seurat <- AddMetaData(object = seurat, metadata = groups, col.name = "group")
# Find Anchors
seurat.list <- SplitObject(seurat, split.by = "group")
seurat.anchors <- FindIntegrationAnchors(object.list = seurat.list, dims = 1:20)
seurat.integrated <- IntegrateData(anchorset = seurat.anchors, dims = 1:20)
seurat.query <- seurat.list[["test"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated,
query = seurat.query,
dims = 1:20)
seurat
seurat.list <- SplitObject(seurat, split.by = "group")
seurat.anchors <- FindIntegrationAnchors(object.list = seurat.list, dims = 1:10)
seurat.integrated <- IntegrateData(anchorset = seurat.anchors, dims = 1:10)
seurat.query <- seurat.list[["test"]]
seurat.anchors <- FindTransferAnchors(reference = seurat.integrated,
query = seurat.query,
dims = 1:10)
?FindTransferAnchors
bookdown::render_book('.')
bookdown::render_book('.')
2^(19/12)
?data.table::fwrite
data("TeachingRatings", package = "AER")
install.packages("AER")
data("TeachingRatings", package = "AER")
rm(list=ls())
data("TeachingRatings", package = "AER")
View(TeachingRatings)
install.packages("BallMapper")
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(BallMapper)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
# counts <- counts[,1:1000]
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(BallMapper)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
# counts <- counts[,1:1000]
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
seurat@reductions$pca
?BallMapper
points <- seurat@reductions$pca[,1:10]
l <- BallMapper(points)
l <- BallMapper(points, epsilon = 0.25)
points <- seurat@reductions$pca[,1:10]
values <- seurat@reductions$pca[,11]
l <- BallMapper(points = points, values = values, epsilon = 0.25)
ColorIgraphPlot(l)
l$vertices
l$edges
l$points_covered_by_landmarks
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
names(l$points_covered_by_landmarks)
points <- seurat@reductions$pca[,1:10]
values <- seurat@reductions$pca[,11]
l <- BallMapper(points = points, values = values, epsilon = 0.2)
ColorIgraphPlot(l)
l <- BallMapper(points = points, values = values, epsilon = 0.1)
ColorIgraphPlot(l)
l <- BallMapper(points = points, values = values, epsilon = 0.15)
ColorIgraphPlot(l)
points <- seurat@reductions$pca[,1:20]
values <- seurat@reductions$pca[,21]
l <- BallMapper(points = points, values = values, epsilon = 0.2)
ColorIgraphPlot(l)
l <- BallMapper(points = points, values = values, epsilon = 0.15)
ColorIgraphPlot(l)
GrayscaleIgraphPlot(l)
seurat@meta.data
l$landmarks
l$points_covered_by_landmarks
seurat@assays$RNA@scale.data
seurat@assays$RNA@scale.data[,seurat@assays$RNA@var.features]
dim(seurat@assays$RNA@scale.data)
seurat@assays$RNA@scale.data[seurat@assays$RNA@var.features,]
points <- seurat@reductions$pca[,1:10]
values <- seurat@reductions$pca[,11]
l <- BallMapper(points = points, values = values, epsilon = 0.2)
ColorIgraphPlot(l)
table(seurat@meta.data$seurat_clusters)
table(seurat@meta.data$RNA_snn_res.1)
l$points_covered_by_landmarks
seurat@meta.data[l$points_covered_by_landmarks[[11]],]
View(seurat@meta.data[l$points_covered_by_landmarks[[11]],])
seurat@meta.data[l$points_covered_by_landmarks[[11]],]
seurat@meta.data[l$points_covered_by_landmarks[[11]],"seurat_clusters"]
table(seurat@meta.data[l$points_covered_by_landmarks[[11]],"seurat_clusters"])
lapply(1:11, function(i) table(seurat@meta.data[l$points_covered_by_landmarks[[i]],"seurat_clusters"]))
prop.table(table(seurat@meta.data[l$points_covered_by_landmarks[[11]],"seurat_clusters"]))
lapply(1:11, function(i) prop.table(table(seurat@meta.data[l$points_covered_by_landmarks[[i]],"seurat_clusters"])))
lapply(1:11, function(i) prop.table(table(seurat@meta.data[l$points_covered_by_landmarks[[i]],"seurat_clusters"]))) %>% do.call(rbind,.)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
names(x = new.cluster.ids) <- levels(x = seurat)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
names(x = new.cluster.ids) <- levels(x = seurat)
dirname <- "/Users/kgosik/Documents/data/cellranger/pbmc3k/"
counts_matrix_filename = paste0(dirname,"/filtered_gene_bc_matrices/hg19/")
counts <- Read10X(data.dir = counts_matrix_filename)  # Seurat function to read in 10x count data
# To minimize memory use on the docker - choose only the first 1000 cells
# counts <- counts[,1:1000]
seurat <- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = "10X_NSCLC")
seurat[["percent.mt"]] <- PercentageFeatureSet(object = seurat, pattern = "^MT-")
seurat <- SubsetData(object = seurat,
subset.names = c("nFeature_RNA", "percent.mt"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
seurat <- NormalizeData(object = seurat, normalization.method = "LogNormalize", scale.factor = 10000)
seurat <- FindVariableFeatures(object = seurat,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
seurat <- ScaleData(object = seurat, vars.to.regress = c("batch", "percent.mt"))
seurat <- RunPCA(object = seurat,
pc.genes = seurat@assays$RNA@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
names(x = new.cluster.ids) <- levels(x = seurat)
set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
#set.seed(2019)
seurat <- FindNeighbors(object = seurat, dims = 1:10)
seurat <- FindClusters(object = seurat,
reduction = "pca",
dims = 1:10,
resolution = 1)
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk")
names(x = new.cluster.ids) <- levels(x = seurat)
points <- seurat@reductions$pca[,1:10]
values <- seurat@reductions$pca[,11]
l <- BallMapper(points = points, values = values, epsilon = 0.2)
