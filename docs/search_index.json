[
["index.html", "ANALYSIS OF SINGLE CELL RNA-SEQ DATA 1 Introduction 1.1 COURSE OVERVIEW 1.2 TARGETED AUDIENCE &amp; ASSUMED BACKGROUND 1.3 COURSE FORMAT 1.4 Getting Started 1.5 SESSION CONTENT", " ANALYSIS OF SINGLE CELL RNA-SEQ DATA Kirk Gosik 01/16/2020 1 Introduction 1.1 COURSE OVERVIEW In recent years single cell RNA-seq (scRNA-seq) has become widely used for transcriptome analysis in many areas of biology. In contrast to bulk RNA-seq, scRNA-seq provides quantitative measurements of the expression of every gene in a single cell. However, to analyze scRNA-seq data, novel methods are required and some of the underlying assumptions for the methods developed for bulk RNA-seq experiments are no longer valid. In this course we will cover all steps of the scRNA-seq processing, starting from the raw reads coming off the sequencer. The course includes common analysis strategies, using state-of-the-art methods and we also discuss the central biological questions that can be addressed using scRNA-seq. 1.2 TARGETED AUDIENCE &amp; ASSUMED BACKGROUND This course is aimed at researchers and technical workers who are or will be analyzing scRNA-seq data. The material is suitable both for experimentalists who want to learn more about data-analysis as well as computational biologists who want to learn about scRNASeq methods. Examples demonstrated in this course can be applied to any experimental protocol or biological system. The requirements for this course are: 1. Working knowledge of unix (managing files, running programs) 2. Programming experience in R (writing a function, basic I/O operations, variable types, using packages). Bioconductor experience is a plus. 3. Familiarity with next-generation sequencing data and its analyses (using alignment and quantification tools for bulk sequencing data) 1.3 COURSE FORMAT The course will be delivered over the course of five days. Each day will include a lecture and laboratory component. The lecture will introduce the topics of discussion and the laboratory sessions will be focused on practical hands-on analysis of scRNA-seq data. These sessions will involve a combination of both mirroring exercises with the instructor to demonstrate a skill as well as applying these skills on your own to complete individual exercises. After and during each exercise, interpretation of results will be discussed as a group. Computing will be done using a combination of tools installed on the attendees laptop computer and web resources accessed via web browser. 1.4 Getting Started 1.5 SESSION CONTENT 1.5.1 Introduction Overview of course General introduction: HCA/KCO overview Comparison of Bulk and single cell RNA-Seq Overview of available scRNA-seq technologies (10x) and experimental protocols scRNA-Seq experimental design and analysis workflow? 1.5.2 Transcriptome Quantification Read &amp; UMI counting (Kallisto alignment-free pseudocounts as well), how RSEM works (length dependence, sequencing depth, multimapping reads), CellRanger (dropest), bustools 10x barcode structure and links to Perturb-seq Gene length &amp; coverage Gene expression units (count data Smart-seq2 counts or 10x UMIs vs expression data) Some R overview slides, https://r4ds.had.co.nz/ 1.5.3 Expression QC and Normalization What CellRanger does for quality filtering PBMC data Normalisation methods https://www.nature.com/articles/nmeth.4292 Doublets, empty droplets Barcode swapping Regression with technical covariates What about imputation? 1.5.4 Data Wrangling scRNAseq Data structures and file formats for single-cell data Quality control of cells and genes (doublets, ambient, empty drops) Data exploration: violin plots… Introducing Seurat object Genes House keeping genes Mitochondrial genes (never used these ones) Filter - Do we remove both cells and genes here? Normalize (introduce more options, other than log transform?) Find variable genes (Is it a first reduction? Why the binning?) Scaling Regression Heatmap of desired genes? Sigantures? 1.5.5 Identifying Cell Populations Feature selection Dimensionality reduction Clustering and assigning identity (Louvain, NMF, topic models, variational autoencoder) Differential expression tests 1.5.6 Feature Selection and Cluster Analysis Parameters and clustering Comparison of feature selection methods "],
["transcriptome-quantification-1.html", "2 Transcriptome Quantification 2.1 Google Slides", " 2 Transcriptome Quantification 2.1 Google Slides "],
["expression-qc-and-normalization-1.html", "3 Expression QC and Normalization 3.1 Google Slides", " 3 Expression QC and Normalization 3.1 Google Slides "],
["data-wrangling-scrnaseq-1.html", "4 Data Wrangling scRNAseq 4.1 Goal 4.2 Introduction 4.3 Filtering low-quality cells 4.4 Beginning with Seurat: 4.5 Preprocessing step 1 : Filter out low-quality cells 4.6 Examine contents of Seurat object 4.7 Detection of variable genes across the single cells 4.8 Gene set expression across cells", " 4 Data Wrangling scRNAseq 4.1 Goal To give you experience with the analysis of single cell RNA sequencing (scRNA-seq) including performing quality control and identifying cell type subsets. To introduce you to scRNA-seq analysis using the Seurat package. 4.2 Introduction Data produced in a single cell RNA-seq experiment has several interesting characteristics that make it distinct from data produced in a bulk population RNA-seq experiment. Two characteristics that are important to keep in mind when working with scRNA-Seq are drop-out (the excessive amount of zeros due to limiting mRNA) and the potential for quality control (QC) metrics to be confounded with biology. This combined with the ability to measure heterogeniety from cells in samples has shifted the field away from the typical analysis in population-based RNA-Seq. Here we demonstrate some approaches to quality control, followed by identifying and analyzing cell subsets. For this tutorial, we will be analyzing the a dataset of Non-Small Cell Lung Cancer Cells (NSCLC) freely available from 10X Genomics (https://support.10xgenomics.com/single-cell-vdj/datasets/2.2.0/vdj_v1_hs_nsclc_5gex), using the Seurat R package (http://satijalab.org/seurat/), a popular and powerful set of tools to conduct scRNA-seq analysis in R. In this dataset, there are 7802 single cells that were sequenced on the Illumina NovaSeq 6000. Please note this tutorial borrows heavily from Seurat’s tutorials, so feel free to go through them in more detail. 4.2.1 Load necessary packages When loading libraries, we are asking R to load code for us written by someone else. It is a convenient way to leverage and reproduce methodology developed by others. knitr::opts_knit$set(progress=FALSE, verbose=FALSE) library(Seurat) library(dplyr) library(Matrix) 4.2.2 Read in NSCLC counts matrix. The data for Non-Small Cell Lung Cancer Cells (NSCLC) is freely available from 10X Genomics (https://support.10xgenomics.com/single-cell-vdj/datasets/2.2.0/vdj_v1_hs_nsclc_5gex). We start by reading in the counts matrix generated by the Cell Ranger count program. Task: Change the directory name to mydir/ where you saved your data Task: Check the dirname to dir where you saved your data ##dirname &lt;- &quot;/home/genomics/workshop_materials/scrna/&quot; dirname &lt;- &quot;/Users/kgosik/Documents/data/cellranger/vdj-nsclc/&quot; counts_matrix_filename = paste0(dirname, &quot;filtered_gene_bc_matrices/GRCh38/&quot;) counts &lt;- Read10X(data.dir = counts_matrix_filename) # Seurat function to read in 10x count data 4.2.3 Let’s examine the sparse counts matrix counts[1:10, 1:3] ## 10 x 3 sparse Matrix of class &quot;dgCMatrix&quot; ## AAACCTGAGCTAGTCT AAACCTGAGGGCACTA ## RP11-34P13.3 . . ## FAM138A . . ## OR4F5 . . ## RP11-34P13.7 . . ## RP11-34P13.8 . . ## RP11-34P13.14 . . ## RP11-34P13.9 . . ## FO538757.3 . . ## FO538757.2 . . ## AP006222.2 . . ## AAACCTGAGTACGTTC ## RP11-34P13.3 . ## FAM138A . ## OR4F5 . ## RP11-34P13.7 . ## RP11-34P13.8 . ## RP11-34P13.14 . ## RP11-34P13.9 . ## FO538757.3 . ## FO538757.2 . ## AP006222.2 . Here we see the upper left corner of the sparse matrix. The columns are indexed by 10x cell barcodes (each 16 nt long), and the rows are the gene names. We mentioned these matrices are sparse, here we see only zeroes (indicated by the “.” symbol); this is the most common value in these sparse matrices. Next, let us look at the dimensions of this matrix. 4.2.4 How big is the matrix? dim(counts) # report number of genes (rows) and number of cells (columns) ## [1] 33694 7802 Here we see the counts matrix has 33694 genes and 7802 cells. 4.2.5 How much memory does a sparse matrix take up relative to a dense matrix? object.size(counts) # size in bytes ## 169457000 bytes object.size(as.matrix(counts)) # size in bytes ## 2106010424 bytes We see here that the sparse matrix takes 225 Mb in memory while storing the matrix in a dense format (where all count values including zeros are stored) takes almost 10 times as much memory! This memory saving is very important, especially as data sets are now being created that are beyond a million cells. These matrices can become unmanageable without special computing resources. In the sparse representation, we assume that the majority of count values in a matrix are zero. We only store the non-zero values. This is implemented in the Matrix package using a dgTMatrix object. 4.3 Filtering low-quality cells You can learn a lot about your scRNA-seq data’s quality with simple plotting. Let’s do some plotting to look at the number of reads per cell, reads per genes, expressed genes per cell (often called complexity), and rarity of genes (cells expressing genes). 4.3.1 Look at the summary counts for genes and cells counts_per_cell &lt;- Matrix::colSums(counts) cat(&quot;counts per cell: &quot;, counts_per_cell[1:5], &quot;\\n&quot;) ## counts for first 5 cells ## counts per cell: 3605 3828 6457 3075 9400 counts_per_gene &lt;- Matrix::rowSums(counts) cat(&quot;counts per gene: &quot;, counts_per_gene[1:5], &quot;\\n&quot;) ## counts for first 5 genes ## counts per gene: 2 0 0 2 0 genes_per_cell &lt;- Matrix::colSums(counts &gt; 0) # count gene only if it has non-zero reads mapped. cat(&quot;counts for non-zero genes: &quot;, genes_per_cell[1:5]) ## counts for first 5 genes ## counts for non-zero genes: 1184 1387 1784 1092 2626 Task: In a similar way, can you calculate cells per genes? replace the ‘?’ in the command below #### cells_per_gene &lt;- Matrix::?(counts&gt;?) # only count cells where the gene is expressed cells_per_gene &lt;- # only count cells where the gene is expressed cat(&quot;count of cells with expressed genes: &quot;, cells_per_gene) colSums and rowSums are functions that work on each row or column in a matrix and return the column sums or row sums as a vector. If this is true counts_per_cell should have 1 entry per cell. Let’s make sure the length of the returned vector matches the matrix dimension for column. How would you do that? ( Hint:length() ). Notes: 1. Matrix::colSums is a way to force functions from the Matrix library to be used. There are many libraries that implement colSums, we are forcing the one from the Matrix library to be used here to make sure it handles the dgTmatrix (sparse matrix) correctly. This is good practice. hist(log10(counts_per_cell+1),main=&#39;counts per cell&#39;,col=&#39;wheat&#39;) hist(log10(genes_per_cell+1), main=&#39;genes per cell&#39;, col=&#39;wheat&#39;) plot(counts_per_cell, genes_per_cell, log=&#39;xy&#39;, col=&#39;wheat&#39;) title(&#39;counts vs genes per cell&#39;) Here we see examples of plotting a new plot, the histogram. R makes this really easy with the hist function. We are also transforming the values to log10 before plotting, this is done with the log10 method. When logging count data, the + 1 is used to avoid log10(0) which is not defined. Can you make a histogram of counts per gene in log10 scale? hist(log10(counts_per_gene+1), main=&#39;counts per gene&#39;, col=&#39;wheat&#39;) ### hist(?(?+1), main=&#39;counts per gene&#39;, col=&#39;wheat&#39;) 4.3.2 Plot cells ranked by their number of detected genes. Here we rank each cell by its library complexity, ie the number of genes detected per cell. This is a very useful plot as it shows the distribution of library complexity in the sequencing run. One can use this plot to investigate observations (potential cells) that are actually failed libraries (lower end outliers) or observations that are cell doublets (higher end outliers). plot(sort(genes_per_cell), xlab=&#39;cell&#39;, log=&#39;y&#39;, main=&#39;genes per cell (ordered)&#39;) 4.4 Beginning with Seurat: http://satijalab.org/seurat/ 4.4.1 Creating a seurat object To analyze our single cell data we will use a seurat object. Can you create an Seurat object with the 10x data and save it in an object called ‘seurat’? hint: CreateSeuratObject(). Can you include only genes that are are expressed in 3 or more cells and cells with complexity of 350 genes or more? How many genes are you left with? How many cells? ### seurat&lt;-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = &quot;10X_NSCLC&quot;) seurat &lt;- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = &quot;10X_NSCLC&quot;) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing ## with dashes (&#39;-&#39;) 4.4.1.1 Object Slots reference Almost all our analysis will be on the single object, of class Seurat. This object contains various “slots” (designated by seurat@slotname) that will store not only the raw count data, but also the results from various computations below. This has the advantage that we do not need to keep track of inidividual variables of interest - they can all be collapsed into a single object as long as these slots are pre-defined as: assays - A list of assays within this object meta.data - Cell-level meta data active.assay - Name of active, or default, assay active.ident - Identity classes for the current object graphs - A list of nearest neighbor graphs reductions - A list of DimReduc objects project.name - User-defined project name (optional) tools - Empty list. Tool developers can store any internal data from their methods here misc - Empty slot. User can store additional information here version Seurat version used when creating the object seurat@assays$RNA@counts is a slot that stores the original gene count matrix. We can view the first 10 rows (genes) and the first 10 columns (cells). seurat@assays$RNA@counts[1:10,1:10] ## 10 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 10 column names &#39;AAACCTGAGCTAGTCT&#39;, &#39;AAACCTGAGGGCACTA&#39;, &#39;AAACCTGAGTACGTTC&#39; ... ]] ## ## FO538757.2 . . . . 1 2 . . . . ## AP006222.2 . . . . . . . . . . ## RP4-669L17.10 . . . . . . . . . . ## RP11-206L10.9 . . . . . . . . . . ## LINC00115 . . . . . . . . . . ## FAM41C . . . . . . . . . . ## SAMD11 . . . . . 1 . . . . ## NOC2L . . . . 2 4 . 1 . . ## KLHL17 . . . . . . . . . . ## PLEKHN1 . . . . . . . . . . 4.4.1.2 Object Information Summary information about Seurat objects can be had quickly and easily using standard R functions. Object shape/dimensions can be found using the dim, ncol, and nrow functions; cell and feature names can be found using the colnames and rownames functions, respectively, or the dimnames function. A vector of names of Assay, DimReduc, and Graph objects contained in a Seurat object can be had by using names. The following examples use the PBMC 3k dataset seurat ## An object of class Seurat ## 20213 features across 7109 samples within 1 assay ## Active assay: RNA (20213 features) # nrow and ncol provide the number of features and cells in the active assay, respectively # dim provides both nrow and ncol at the same time dim(x = seurat) ## [1] 20213 7109 # In addtion to rownames and colnames, one can use dimnames # which provides a two-length list with both rownames and colnames head(x = rownames(x = seurat)) ## [1] &quot;FO538757.2&quot; &quot;AP006222.2&quot; &quot;RP4-669L17.10&quot; ## [4] &quot;RP11-206L10.9&quot; &quot;LINC00115&quot; &quot;FAM41C&quot; head(x = colnames(x = seurat)) ## [1] &quot;AAACCTGAGCTAGTCT&quot; &quot;AAACCTGAGGGCACTA&quot; &quot;AAACCTGAGTACGTTC&quot; ## [4] &quot;AAACCTGAGTCCGGTC&quot; &quot;AAACCTGCACCAGGTC&quot; &quot;AAACCTGCACCTCGTT&quot; # A vector of names of associated objects can be had with the names function # These can be passed to the double [[ extract operator to pull them from the Seurat object names(x = seurat) ## [1] &quot;RNA&quot; You can also see a print out of the entire structure of the object by using the str commmand. str(seurat) ## Formal class &#39;Seurat&#39; [package &quot;Seurat&quot;] with 12 slots ## ..@ assays :List of 1 ## .. ..$ RNA:Formal class &#39;Assay&#39; [package &quot;Seurat&quot;] with 8 slots ## .. .. .. ..@ counts :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:13732088] 22 37 100 102 105 132 146 171 177 185 ... ## .. .. .. .. .. ..@ p : int [1:7110] 0 1184 2571 4355 5447 8072 13674 15861 17504 18605 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 20213 7109 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:20213] &quot;FO538757.2&quot; &quot;AP006222.2&quot; &quot;RP4-669L17.10&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:7109] &quot;AAACCTGAGCTAGTCT&quot; &quot;AAACCTGAGGGCACTA&quot; &quot;AAACCTGAGTACGTTC&quot; &quot;AAACCTGAGTCCGGTC&quot; ... ## .. .. .. .. .. ..@ x : num [1:13732088] 1 2 7 1 1 3 1 1 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ data :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:13732088] 22 37 100 102 105 132 146 171 177 185 ... ## .. .. .. .. .. ..@ p : int [1:7110] 0 1184 2571 4355 5447 8072 13674 15861 17504 18605 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 20213 7109 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:20213] &quot;FO538757.2&quot; &quot;AP006222.2&quot; &quot;RP4-669L17.10&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:7109] &quot;AAACCTGAGCTAGTCT&quot; &quot;AAACCTGAGGGCACTA&quot; &quot;AAACCTGAGTACGTTC&quot; &quot;AAACCTGAGTCCGGTC&quot; ... ## .. .. .. .. .. ..@ x : num [1:13732088] 1 2 7 1 1 3 1 1 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ scale.data : num[0 , 0 ] ## .. .. .. ..@ key : chr &quot;rna_&quot; ## .. .. .. ..@ assay.orig : NULL ## .. .. .. ..@ var.features : logi(0) ## .. .. .. ..@ meta.features:&#39;data.frame&#39;: 20213 obs. of 0 variables ## .. .. .. ..@ misc : NULL ## ..@ meta.data :&#39;data.frame&#39;: 7109 obs. of 3 variables: ## .. ..$ orig.ident : Factor w/ 1 level &quot;10X_NSCLC&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ nCount_RNA : num [1:7109] 3605 3828 6457 3075 9399 ... ## .. ..$ nFeature_RNA: int [1:7109] 1184 1387 1784 1092 2625 5602 2187 1643 1101 2717 ... ## ..@ active.assay: chr &quot;RNA&quot; ## ..@ active.ident: Factor w/ 1 level &quot;10X_NSCLC&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:7109] &quot;AAACCTGAGCTAGTCT&quot; &quot;AAACCTGAGGGCACTA&quot; &quot;AAACCTGAGTACGTTC&quot; &quot;AAACCTGAGTCCGGTC&quot; ... ## ..@ graphs : list() ## ..@ neighbors : list() ## ..@ reductions : list() ## ..@ project.name: chr &quot;10X_NSCLC&quot; ## ..@ misc : list() ## ..@ version :Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. ..$ : int [1:3] 3 1 2 ## ..@ commands : list() ## ..@ tools : list() 4.4.1.3 Data Access Pulling specific Assay, DimReduc, or Graph objects can be done with the double [[ extract operator. Adding new objects to a Seurat object is also done with the double [[ extract operator; Seurat will figure out where in the Seurat object a new associated object belongs. seurat[[&#39;RNA&#39;]] ## Assay data with 20213 features for 7109 cells ## First 10 features: ## FO538757.2, AP006222.2, RP4-669L17.10, RP11-206L10.9, ## LINC00115, FAM41C, SAMD11, NOC2L, KLHL17, PLEKHN1 Accessing data from an Seurat object is done with the GetAssayData function. Adding expression data to either the counts, data, or scale.data slots can be done with SetAssayData. New data must have the same cells in the same order as the current expression data. Data added to counts or data must have the same features as the current expression data. ## same as above but using object Method GetAssayData(object = seurat, slot = &#39;data&#39;)[1:10, 1:10] ## 10 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 10 column names &#39;AAACCTGAGCTAGTCT&#39;, &#39;AAACCTGAGGGCACTA&#39;, &#39;AAACCTGAGTACGTTC&#39; ... ]] ## ## FO538757.2 . . . . 1 2 . . . . ## AP006222.2 . . . . . . . . . . ## RP4-669L17.10 . . . . . . . . . . ## RP11-206L10.9 . . . . . . . . . . ## LINC00115 . . . . . . . . . . ## FAM41C . . . . . . . . . . ## SAMD11 . . . . . 1 . . . . ## NOC2L . . . . 2 4 . 1 . . ## KLHL17 . . . . . . . . . . ## PLEKHN1 . . . . . . . . . . Cell-level meta data can be accessed with the single [ extract operator or using the $ sign. Pulling with the $ sign means only one bit of meta data can be pulled at a time, though tab-autocompletion has been enabled for it, making it ideal for interactive use. Adding cell-level meta data can be set using the single [ extract operator as well, or by using AddMetaData. # Cell-level meta data is stored as a data frame # Standard data frame functions work on the meta data data frame colnames(x = seurat[]) ## [1] &quot;AAACCTGAGCTAGTCT&quot; &quot;AAACCTGAGGGCACTA&quot; &quot;AAACCTGAGTACGTTC&quot; ## [4] &quot;AAACCTGAGTCCGGTC&quot; &quot;AAACCTGCACCAGGTC&quot; &quot;AAACCTGCACCTCGTT&quot; ## [7] &quot;AAACCTGCAGCTGTGC&quot; &quot;AAACCTGGTAAATGAC&quot; &quot;AAACCTGGTACTTAGC&quot; ## [10] &quot;AAACCTGTCCTCAATT&quot; &quot;AAACCTGTCCTGCAGG&quot; &quot;AAACGGGAGCTTATCG&quot; ## [13] &quot;AAACGGGAGGCCCTTG&quot; &quot;AAACGGGCAAGTAATG&quot; &quot;AAACGGGCACCAGATT&quot; ## [16] &quot;AAACGGGGTAATCACC&quot; &quot;AAACGGGGTAGCTGCC&quot; &quot;AAACGGGGTGGTGTAG&quot; ## [19] &quot;AAACGGGTCACCTCGT&quot; &quot;AAACGGGTCCCAAGTA&quot; &quot;AAAGATGAGAAACCTA&quot; ## [22] &quot;AAAGATGAGACTTTCG&quot; &quot;AAAGATGAGATATGGT&quot; &quot;AAAGATGAGATCCGAG&quot; ## [25] &quot;AAAGATGAGATGAGAG&quot; &quot;AAAGATGAGCCAGTAG&quot; &quot;AAAGATGCAATCCAAC&quot; ## [28] &quot;AAAGATGCACGAAATA&quot; &quot;AAAGATGCACGTAAGG&quot; &quot;AAAGATGCAGAGTGTG&quot; ## [31] &quot;AAAGATGCAGCCAGAA&quot; &quot;AAAGATGCAGGACCCT&quot; &quot;AAAGATGGTCATACTG&quot; ## [34] &quot;AAAGATGGTCCGTGAC&quot; &quot;AAAGATGGTCGAAAGC&quot; &quot;AAAGATGGTGCCTGGT&quot; ## [37] &quot;AAAGATGGTTACCGAT&quot; &quot;AAAGATGGTTGGTAAA&quot; &quot;AAAGATGTCAGCGATT&quot; ## [40] &quot;AAAGATGTCCCAAGTA&quot; &quot;AAAGATGTCCGAATGT&quot; &quot;AAAGATGTCCTAGTGA&quot; ## [43] &quot;AAAGATGTCGAACTGT&quot; &quot;AAAGATGTCTGTCTCG&quot; &quot;AAAGCAAAGAATTGTG&quot; ## [46] &quot;AAAGCAAAGAGACGAA&quot; &quot;AAAGCAAAGAGTTGGC&quot; &quot;AAAGCAACAAGGTTCT&quot; ## [49] &quot;AAAGCAACACGCCAGT&quot; &quot;AAAGCAAGTAGCTGCC&quot; &quot;AAAGCAAGTGCCTGTG&quot; ## [52] &quot;AAAGCAAGTTAGTGGG&quot; &quot;AAAGCAATCACTATTC&quot; &quot;AAAGCAATCATCGGAT&quot; ## [55] &quot;AAAGCAATCATCTGCC&quot; &quot;AAAGCAATCCTAGAAC&quot; &quot;AAAGCAATCGAACGGA&quot; ## [58] &quot;AAAGCAATCGTACGGC&quot; &quot;AAAGCAATCTCAAGTG&quot; &quot;AAAGTAGAGAGTAATC&quot; ## [61] &quot;AAAGTAGAGCCGATTT&quot; &quot;AAAGTAGAGGATTCGG&quot; &quot;AAAGTAGCAATGTAAG&quot; ## [64] &quot;AAAGTAGCACGACTCG&quot; &quot;AAAGTAGGTAATTGGA&quot; &quot;AAAGTAGGTATCAGTC&quot; ## [67] &quot;AAAGTAGGTCGCGAAA&quot; &quot;AAAGTAGGTGGTCCGT&quot; &quot;AAAGTAGGTTGCCTCT&quot; ## [70] &quot;AAAGTAGTCAGGCAAG&quot; &quot;AAAGTAGTCCAAAGTC&quot; &quot;AAAGTAGTCTTGTCAT&quot; ## [73] &quot;AAATGCCAGACGACGT&quot; &quot;AAATGCCAGGCAAAGA&quot; &quot;AAATGCCAGGGTGTTG&quot; ## [76] &quot;AAATGCCAGGTAAACT&quot; &quot;AAATGCCCAATGTAAG&quot; &quot;AAATGCCCACACATGT&quot; ## [79] &quot;AAATGCCCAGCTCGAC&quot; &quot;AAATGCCCATCTATGG&quot; &quot;AAATGCCGTACTTCTT&quot; ## [82] &quot;AAATGCCGTCTTGCGG&quot; &quot;AAATGCCGTGTAACGG&quot; &quot;AAATGCCTCCAAACAC&quot; ## [85] &quot;AAATGCCTCCGCGGTA&quot; &quot;AAATGCCTCGTCGTTC&quot; &quot;AACACGTAGCTAGTCT&quot; ## [88] &quot;AACACGTAGGATTCGG&quot; &quot;AACACGTAGTACCGGA&quot; &quot;AACACGTCACAGAGGT&quot; ## [91] &quot;AACACGTCACGACTCG&quot; &quot;AACACGTCAGTCAGCC&quot; &quot;AACACGTGTAATCGTC&quot; ## [94] &quot;AACACGTGTACCAGTT&quot; &quot;AACACGTGTTGGGACA&quot; &quot;AACACGTTCACCACCT&quot; ## [97] &quot;AACACGTTCACCGGGT&quot; &quot;AACACGTTCCAGAGGA&quot; &quot;AACACGTTCCTGCAGG&quot; ## [100] &quot;AACACGTTCGCATGGC&quot; &quot;AACACGTTCTTACCGC&quot; &quot;AACACGTTCTTGCATT&quot; ## [103] &quot;AACCATGAGTAGTGCG&quot; &quot;AACCATGCAAAGGCGT&quot; &quot;AACCATGCAAGCGAGT&quot; ## [106] &quot;AACCATGCAGCATACT&quot; &quot;AACCATGCATGTTGAC&quot; &quot;AACCATGCATTCTCAT&quot; ## [109] &quot;AACCATGGTCCGAAGA&quot; &quot;AACCATGGTGCCTGCA&quot; &quot;AACCATGGTGTTGAGG&quot; ## [112] &quot;AACCATGGTTGATTCG&quot; &quot;AACCATGTCAATCTCT&quot; &quot;AACCATGTCCGAAGAG&quot; ## [115] &quot;AACCATGTCTCCGGTT&quot; &quot;AACCGCGAGAGGTTGC&quot; &quot;AACCGCGAGGGTCTCC&quot; ## [118] &quot;AACCGCGCAAGGTGTG&quot; &quot;AACCGCGCAGGACGTA&quot; &quot;AACCGCGCAGGGTTAG&quot; ## [121] &quot;AACCGCGCAGTAACGG&quot; &quot;AACCGCGCATTCCTGC&quot; &quot;AACCGCGGTGACTCAT&quot; ## [124] &quot;AACCGCGGTGGGTCAA&quot; &quot;AACCGCGTCAATCTCT&quot; &quot;AACCGCGTCCTTGGTC&quot; ## [127] &quot;AACCGCGTCGCACTCT&quot; &quot;AACCGCGTCGGCCGAT&quot; &quot;AACCGCGTCTTGCCGT&quot; ## [130] &quot;AACGTTGAGAACTCGG&quot; &quot;AACGTTGAGGGTGTGT&quot; &quot;AACGTTGCAGGTCGTC&quot; ## [133] &quot;AACGTTGCAGTCGTGC&quot; &quot;AACGTTGCATATACGC&quot; &quot;AACGTTGTCATACGGT&quot; ## [136] &quot;AACGTTGTCCACGACG&quot; &quot;AACGTTGTCCGTCATC&quot; &quot;AACGTTGTCTGGTATG&quot; ## [139] &quot;AACTCAGAGACTAAGT&quot; &quot;AACTCAGAGCGTAATA&quot; &quot;AACTCAGAGCGTCTAT&quot; ## [142] &quot;AACTCAGAGCTGAAAT&quot; &quot;AACTCAGAGTGGACGT&quot; &quot;AACTCAGCACATAACC&quot; ## [145] &quot;AACTCAGGTGTTCGAT&quot; &quot;AACTCAGGTTCTCATT&quot; &quot;AACTCAGTCACCCTCA&quot; ## [148] &quot;AACTCAGTCAGCCTAA&quot; &quot;AACTCAGTCCTATGTT&quot; &quot;AACTCAGTCTAACCGA&quot; ## [151] &quot;AACTCAGTCTCGTATT&quot; &quot;AACTCCCAGACAAGCC&quot; &quot;AACTCCCAGACTAGGC&quot; ## [154] &quot;AACTCCCAGGATCGCA&quot; &quot;AACTCCCAGGCAGGTT&quot; &quot;AACTCCCAGTACGTTC&quot; ## [157] &quot;AACTCCCAGTCGTTTG&quot; &quot;AACTCCCAGTGACTCT&quot; &quot;AACTCCCCACAAGTAA&quot; ## [160] &quot;AACTCCCCACGCATCG&quot; &quot;AACTCCCCAGTATCTG&quot; &quot;AACTCCCCATCCTAGA&quot; ## [163] &quot;AACTCCCCATCGTCGG&quot; &quot;AACTCCCGTCGAACAG&quot; &quot;AACTCCCGTGCACGAA&quot; ## [166] &quot;AACTCCCGTTCACCTC&quot; &quot;AACTCCCTCAGTTTGG&quot; &quot;AACTCCCTCTGGTGTA&quot; ## [169] &quot;AACTCTTCAAGAAGAG&quot; &quot;AACTCTTCAAGTCTGT&quot; &quot;AACTCTTCAATGTTGC&quot; ## [172] &quot;AACTCTTCATCTCCCA&quot; &quot;AACTCTTCATTTCAGG&quot; &quot;AACTCTTGTGCGGTAA&quot; ## [175] &quot;AACTCTTGTGTCCTCT&quot; &quot;AACTCTTGTTTGGGCC&quot; &quot;AACTCTTTCAACGAAA&quot; ## [178] &quot;AACTCTTTCCTTGCCA&quot; &quot;AACTCTTTCTCGTTTA&quot; &quot;AACTGGTAGAGGTACC&quot; ## [181] &quot;AACTGGTAGGGAAACA&quot; &quot;AACTGGTAGGTGTGGT&quot; &quot;AACTGGTAGTACGACG&quot; ## [184] &quot;AACTGGTCAAACTGCT&quot; &quot;AACTGGTCACGAGGTA&quot; &quot;AACTGGTGTACATGTC&quot; ## [187] &quot;AACTGGTGTGGCAAAC&quot; &quot;AACTGGTGTTACCAGT&quot; &quot;AACTGGTGTTGAGGTG&quot; ## [190] &quot;AACTGGTGTTGGAGGT&quot; &quot;AACTGGTGTTTGACAC&quot; &quot;AACTGGTGTTTGTTTC&quot; ## [193] &quot;AACTGGTTCAATCACG&quot; &quot;AACTGGTTCACAAACC&quot; &quot;AACTGGTTCACCCGAG&quot; ## [196] &quot;AACTGGTTCAGCACAT&quot; &quot;AACTGGTTCCTTTACA&quot; &quot;AACTGGTTCGGGAGTA&quot; ## [199] &quot;AACTGGTTCGTCACGG&quot; &quot;AACTGGTTCTCTTATG&quot; &quot;AACTTTCAGGCAGTCA&quot; ## [202] &quot;AACTTTCAGGTTACCT&quot; &quot;AACTTTCCACCAGGCT&quot; &quot;AACTTTCCAGGTGCCT&quot; ## [205] &quot;AACTTTCCATGAACCT&quot; &quot;AACTTTCCATGTAAGA&quot; &quot;AACTTTCCATGTCCTC&quot; ## [208] &quot;AACTTTCGTAAGTGTA&quot; &quot;AACTTTCGTACACCGC&quot; &quot;AACTTTCGTATAGGTA&quot; ## [211] &quot;AACTTTCGTCTAGTCA&quot; &quot;AACTTTCGTTAAAGAC&quot; &quot;AACTTTCGTTACGGAG&quot; ## [214] &quot;AACTTTCGTTGTGGAG&quot; &quot;AACTTTCTCACTCCTG&quot; &quot;AACTTTCTCGAACTGT&quot; ## [217] &quot;AACTTTCTCGCAAACT&quot; &quot;AACTTTCTCTTGCAAG&quot; &quot;AAGACCTAGAGGTAGA&quot; ## [220] &quot;AAGACCTAGGATATAC&quot; &quot;AAGACCTAGGCTATCT&quot; &quot;AAGACCTAGTCCAGGA&quot; ## [223] &quot;AAGACCTAGTCGTTTG&quot; &quot;AAGACCTAGTGACATA&quot; &quot;AAGACCTCAAGCCTAT&quot; ## [226] &quot;AAGACCTCAATGAATG&quot; &quot;AAGACCTCATACAGCT&quot; &quot;AAGACCTCATGGGAAC&quot; ## [229] &quot;AAGACCTCATTTGCCC&quot; &quot;AAGACCTGTAATAGCA&quot; &quot;AAGACCTGTAGCTAAA&quot; ## [232] &quot;AAGACCTGTCCGAGTC&quot; &quot;AAGACCTGTCTAGAGG&quot; &quot;AAGACCTGTGAAAGAG&quot; ## [235] &quot;AAGACCTGTTGACGTT&quot; &quot;AAGACCTTCACCGTAA&quot; &quot;AAGACCTTCCGGCACA&quot; ## [238] &quot;AAGACCTTCTCCAGGG&quot; &quot;AAGCCGCAGAGTCGGT&quot; &quot;AAGCCGCAGCACGCCT&quot; ## [241] &quot;AAGCCGCAGCCAGGAT&quot; &quot;AAGCCGCAGCTGCGAA&quot; &quot;AAGCCGCCACGACGAA&quot; ## [244] &quot;AAGCCGCCATGGTTGT&quot; &quot;AAGCCGCCATTCCTCG&quot; &quot;AAGCCGCGTACGCACC&quot; ## [247] &quot;AAGCCGCGTCCTCCAT&quot; &quot;AAGCCGCGTTACCAGT&quot; &quot;AAGCCGCGTTGACGTT&quot; ## [250] &quot;AAGCCGCTCATGCAAC&quot; &quot;AAGCCGCTCCAGAGGA&quot; &quot;AAGCCGCTCCTATTCA&quot; ## [253] &quot;AAGCCGCTCCTCCTAG&quot; &quot;AAGCCGCTCGGATGGA&quot; &quot;AAGCCGCTCGTAGGAG&quot; ## [256] &quot;AAGCCGCTCTAACTGG&quot; &quot;AAGGAGCAGATGGCGT&quot; &quot;AAGGAGCAGCCCAATT&quot; ## [259] &quot;AAGGAGCAGCGGCTTC&quot; &quot;AAGGAGCAGGATATAC&quot; &quot;AAGGAGCAGTAACCCT&quot; ## [262] &quot;AAGGAGCCAGACGCTC&quot; &quot;AAGGAGCCAGACGTAG&quot; &quot;AAGGAGCCAGCCTATA&quot; ## [265] &quot;AAGGAGCGTCTCAACA&quot; &quot;AAGGAGCTCAATCACG&quot; &quot;AAGGAGCTCAGGCAAG&quot; ## [268] &quot;AAGGAGCTCGGAAACG&quot; &quot;AAGGAGCTCTAGCACA&quot; &quot;AAGGAGCTCTCAAACG&quot; ## [271] &quot;AAGGAGCTCTTGAGAC&quot; &quot;AAGGCAGAGGATGGAA&quot; &quot;AAGGCAGAGTGACATA&quot; ## [274] &quot;AAGGCAGCAAGTAATG&quot; &quot;AAGGCAGCACACATGT&quot; &quot;AAGGCAGCACGAGGTA&quot; ## [277] &quot;AAGGCAGCATACTACG&quot; &quot;AAGGCAGCATCAGTAC&quot; &quot;AAGGCAGCATTCACTT&quot; ## [280] &quot;AAGGCAGGTAGCCTAT&quot; &quot;AAGGCAGGTGATGTGG&quot; &quot;AAGGCAGGTGTTTGGT&quot; ## [283] &quot;AAGGCAGGTTGTGGCC&quot; &quot;AAGGCAGTCAATAAGG&quot; &quot;AAGGCAGTCTGCTGTC&quot; ## [286] &quot;AAGGTTCAGAACAATC&quot; &quot;AAGGTTCAGAATCTCC&quot; &quot;AAGGTTCAGCGTTGCC&quot; ## [289] &quot;AAGGTTCAGGCCGAAT&quot; &quot;AAGGTTCAGGCTATCT&quot; &quot;AAGGTTCAGGGTGTGT&quot; ## [292] &quot;AAGGTTCAGTCAAGCG&quot; &quot;AAGGTTCAGTTACCCA&quot; &quot;AAGGTTCCAACACCCG&quot; ## [295] &quot;AAGGTTCCACAGCGTC&quot; &quot;AAGGTTCCACTAAGTC&quot; &quot;AAGGTTCCACTTGGAT&quot; ## [298] &quot;AAGGTTCCATAAGACA&quot; &quot;AAGGTTCCATCACAAC&quot; &quot;AAGGTTCCATCGGACC&quot; ## [301] &quot;AAGGTTCGTATAGTAG&quot; &quot;AAGGTTCGTGATGATA&quot; &quot;AAGGTTCGTTATGCGT&quot; ## [304] &quot;AAGGTTCGTTCCGGCA&quot; &quot;AAGGTTCTCCCTTGTG&quot; &quot;AAGTCTGAGATGTGGC&quot; ## [307] &quot;AAGTCTGAGGATCGCA&quot; &quot;AAGTCTGCAAGCCGCT&quot; &quot;AAGTCTGGTTCCTCCA&quot; ## [310] &quot;AAGTCTGTCAACCATG&quot; &quot;AAGTCTGTCATAGCAC&quot; &quot;AAGTCTGTCCAAGCCG&quot; ## [313] &quot;AAGTCTGTCTAACTTC&quot; &quot;AATCCAGAGCTGATAA&quot; &quot;AATCCAGAGGCTCAGA&quot; ## [316] &quot;AATCCAGAGGGATCTG&quot; &quot;AATCCAGAGGTGTTAA&quot; &quot;AATCCAGCACATCTTT&quot; ## [319] &quot;AATCCAGCACGAAACG&quot; &quot;AATCCAGCACGGATAG&quot; &quot;AATCCAGCAGACGCTC&quot; ## [322] &quot;AATCCAGGTCAGAGGT&quot; &quot;AATCCAGGTCGGCTCA&quot; &quot;AATCCAGGTTCCCGAG&quot; ## [325] &quot;AATCCAGGTTCGGGCT&quot; &quot;AATCCAGGTTGGTGGA&quot; &quot;AATCCAGTCAGAGCTT&quot; ## [328] &quot;AATCCAGTCCATTCTA&quot; &quot;AATCCAGTCCTGCAGG&quot; &quot;AATCGGTAGCCACGTC&quot; ## [331] &quot;AATCGGTAGGGATACC&quot; &quot;AATCGGTCAACGCACC&quot; &quot;AATCGGTCACCATCCT&quot; ## [334] &quot;AATCGGTCAGCGAACA&quot; &quot;AATCGGTCATGTCCTC&quot; &quot;AATCGGTCATTATCTC&quot; ## [337] &quot;AATCGGTGTCGGATCC&quot; &quot;AATCGGTGTCTGGTCG&quot; &quot;AATCGGTGTTTGCATG&quot; ## [340] &quot;AATCGGTTCAAACGGG&quot; &quot;AATCGGTTCAACGCTA&quot; &quot;AATCGGTTCCACGCAG&quot; ## [343] &quot;AATCGGTTCCCGGATG&quot; &quot;AATCGGTTCGTGGACC&quot; &quot;AATCGGTTCTACCAGA&quot; ## [346] &quot;AATCGGTTCTAGCACA&quot; &quot;ACACCAAAGCGATATA&quot; &quot;ACACCAAAGCTCCCAG&quot; ## [349] &quot;ACACCAAAGTGGTAGC&quot; &quot;ACACCAAAGTGTCCAT&quot; &quot;ACACCAACAAGTCATC&quot; ## [352] &quot;ACACCAACACACGCTG&quot; &quot;ACACCAACACAGCCCA&quot; &quot;ACACCAACAGGTCTCG&quot; ## [355] &quot;ACACCAACATCGGAAG&quot; &quot;ACACCAAGTCAAACTC&quot; &quot;ACACCAAGTCGGCTCA&quot; ## [358] &quot;ACACCAAGTCTGGTCG&quot; &quot;ACACCAAGTGACAAAT&quot; &quot;ACACCAAGTGCTTCTC&quot; ## [361] &quot;ACACCAAGTGGACGAT&quot; &quot;ACACCAATCATCGGAT&quot; &quot;ACACCAATCCGTAGTA&quot; ## [364] &quot;ACACCAATCGTCTGAA&quot; &quot;ACACCAATCGTTGCCT&quot; &quot;ACACCCTAGACCTAGG&quot; ## [367] &quot;ACACCCTAGCCAGTAG&quot; &quot;ACACCCTAGTAGCGGT&quot; &quot;ACACCCTCAACTGCTA&quot; ## [370] &quot;ACACCCTCAGCCAGAA&quot; &quot;ACACCCTCATCGGTTA&quot; &quot;ACACCCTCATGCCACG&quot; ## [373] &quot;ACACCCTCATGTCGAT&quot; &quot;ACACCCTCATTATCTC&quot; &quot;ACACCCTGTAGGACAC&quot; ## [376] &quot;ACACCCTTCAAACAAG&quot; &quot;ACACCCTTCATATCGG&quot; &quot;ACACCCTTCATTATCC&quot; ## [379] &quot;ACACCCTTCCAGGGCT&quot; &quot;ACACCCTTCCCTAATT&quot; &quot;ACACCCTTCCGTTGCT&quot; ## [382] &quot;ACACCCTTCGCGCCAA&quot; &quot;ACACCCTTCGTAGGTT&quot; &quot;ACACCCTTCGTTACGA&quot; ## [385] &quot;ACACCCTTCTGGGCCA&quot; &quot;ACACCGGAGAGCTATA&quot; &quot;ACACCGGAGCACCGCT&quot; ## [388] &quot;ACACCGGAGGCATGGT&quot; &quot;ACACCGGAGGCTATCT&quot; &quot;ACACCGGAGTCATCCA&quot; ## [391] &quot;ACACCGGAGTGAAGAG&quot; &quot;ACACCGGAGTGGGATC&quot; &quot;ACACCGGCAAGCCGTC&quot; ## [394] &quot;ACACCGGCAGGTCTCG&quot; &quot;ACACCGGGTGACTACT&quot; &quot;ACACCGGGTTCGCTAA&quot; ## [397] &quot;ACACCGGTCGCCTGTT&quot; &quot;ACACCGGTCTTAGAGC&quot; &quot;ACACTGAAGACAGACC&quot; ## [400] &quot;ACACTGAAGTACTTGC&quot; &quot;ACACTGAAGTCTTGCA&quot; &quot;ACACTGACAACTGCGC&quot; ## [403] &quot;ACACTGACAAGAGGCT&quot; &quot;ACACTGACAAGCCGCT&quot; &quot;ACACTGACACCCAGTG&quot; ## [406] &quot;ACACTGACACTCAGGC&quot; &quot;ACACTGAGTACACCGC&quot; &quot;ACACTGAGTAGGGTAC&quot; ## [409] &quot;ACACTGAGTCGCATAT&quot; &quot;ACACTGAGTCTCTCTG&quot; &quot;ACACTGAGTGGCAAAC&quot; ## [412] &quot;ACACTGAGTGTCCTCT&quot; &quot;ACACTGAGTTGAGTTC&quot; &quot;ACACTGATCAGTGCAT&quot; ## [415] &quot;ACAGCCGAGACCACGA&quot; &quot;ACAGCCGAGACTAGGC&quot; &quot;ACAGCCGAGCTACCGC&quot; ## [418] &quot;ACAGCCGAGTTCGCGC&quot; &quot;ACAGCCGCAACGATCT&quot; &quot;ACAGCCGCACCAGGTC&quot; ## [421] &quot;ACAGCCGCACCATCCT&quot; &quot;ACAGCCGCATGGGACA&quot; &quot;ACAGCCGGTACCGGCT&quot; ## [424] &quot;ACAGCCGGTAGCGTAG&quot; &quot;ACAGCCGGTTCAGGCC&quot; &quot;ACAGCCGGTTCCACTC&quot; ## [427] &quot;ACAGCCGGTTTCGCTC&quot; &quot;ACAGCCGTCAGGCCCA&quot; &quot;ACAGCCGTCCCATTAT&quot; ## [430] &quot;ACAGCCGTCGTGGACC&quot; &quot;ACAGCCGTCTGATTCT&quot; &quot;ACAGCTAAGATGGCGT&quot; ## [433] &quot;ACAGCTAAGCGTAGTG&quot; &quot;ACAGCTACAATAGCAA&quot; &quot;ACAGCTATCACATGCA&quot; ## [436] &quot;ACAGCTATCCAACCAA&quot; &quot;ACAGCTATCGTAGGAG&quot; &quot;ACAGCTATCTCGGACG&quot; ## [439] &quot;ACATACGAGAATTGTG&quot; &quot;ACATACGAGAGTCTGG&quot; &quot;ACATACGCAAGCCGTC&quot; ## [442] &quot;ACATACGCAGACGTAG&quot; &quot;ACATACGCATCGGACC&quot; &quot;ACATACGGTCATTAGC&quot; ## [445] &quot;ACATACGGTCGGCACT&quot; &quot;ACATACGGTCTAGTCA&quot; &quot;ACATACGTCATGCTCC&quot; ## [448] &quot;ACATCAGAGTCCCACG&quot; &quot;ACATCAGAGTTATCGC&quot; &quot;ACATCAGCACACCGCA&quot; ## [451] &quot;ACATCAGCACAGTCGC&quot; &quot;ACATCAGCACGCGAAA&quot; &quot;ACATCAGCATCCCACT&quot; ## [454] &quot;ACATCAGCATTCTTAC&quot; &quot;ACATCAGCATTTGCTT&quot; &quot;ACATCAGGTCGAACAG&quot; ## [457] &quot;ACATCAGGTCTCGTTC&quot; &quot;ACATCAGGTGAAAGAG&quot; &quot;ACATCAGGTGCATCTA&quot; ## [460] &quot;ACATCAGTCACCGTAA&quot; &quot;ACATCAGTCAGTCAGT&quot; &quot;ACATCAGTCGAACGGA&quot; ## [463] &quot;ACATCAGTCGACAGCC&quot; &quot;ACATCAGTCGCACTCT&quot; &quot;ACATCAGTCTTTACGT&quot; ## [466] &quot;ACATGGTAGACTTGAA&quot; &quot;ACATGGTAGTAGTGCG&quot; &quot;ACATGGTCAAAGCGGT&quot; ## [469] &quot;ACATGGTCAATAAGCA&quot; &quot;ACATGGTCAATGAATG&quot; &quot;ACATGGTCATGCAATC&quot; ## [472] &quot;ACATGGTCATGGTCAT&quot; &quot;ACATGGTGTGTGCCTG&quot; &quot;ACATGGTGTTGATTCG&quot; ## [475] &quot;ACATGGTTCAATCTCT&quot; &quot;ACATGGTTCCGCGTTT&quot; &quot;ACATGGTTCCTAAGTG&quot; ## [478] &quot;ACATGGTTCGTACGGC&quot; &quot;ACATGGTTCGTTTATC&quot; &quot;ACATGGTTCTACTATC&quot; ## [481] &quot;ACATGGTTCTGCCAGG&quot; &quot;ACCAGTAAGAGAGCTC&quot; &quot;ACCAGTACACGGTGTC&quot; ## [484] &quot;ACCAGTACATGCAATC&quot; &quot;ACCAGTAGTCTCTCGT&quot; &quot;ACCAGTAGTGCCTGCA&quot; ## [487] &quot;ACCAGTAGTTCCCGAG&quot; &quot;ACCAGTAGTTTGGCGC&quot; &quot;ACCAGTATCCAATGGT&quot; ## [490] &quot;ACCAGTATCCATGAAC&quot; &quot;ACCCACTAGAATTCCC&quot; &quot;ACCCACTAGCGGATCA&quot; ## [493] &quot;ACCCACTAGCTCCTCT&quot; &quot;ACCCACTAGGCTCATT&quot; &quot;ACCCACTCAAAGCAAT&quot; ## [496] &quot;ACCCACTCAACACCCG&quot; &quot;ACCCACTCAGATCGGA&quot; &quot;ACCCACTCATGGTAGG&quot; ## [499] &quot;ACCCACTGTCATTAGC&quot; &quot;ACCCACTGTCCTCTTG&quot; &quot;ACCCACTGTCTCTTAT&quot; ## [502] &quot;ACCCACTGTGGCAAAC&quot; &quot;ACCCACTGTTCCGGCA&quot; &quot;ACCCACTGTTGTTTGG&quot; ## [505] &quot;ACCCACTTCCTTGACC&quot; &quot;ACCCACTTCGGTGTTA&quot; &quot;ACCGTAAAGAGTGAGA&quot; ## [508] &quot;ACCGTAAAGGTAAACT&quot; &quot;ACCGTAACACACGCTG&quot; &quot;ACCGTAACAGCTCGAC&quot; ## [511] &quot;ACCGTAACAGCTGTAT&quot; &quot;ACCGTAACATCCTAGA&quot; &quot;ACCGTAACATGGGAAC&quot; ## [514] &quot;ACCGTAACATTTCAGG&quot; &quot;ACCGTAAGTTCGCGAC&quot; &quot;ACCGTAATCCTATGTT&quot; ## [517] &quot;ACCGTAATCGGTGTTA&quot; &quot;ACCGTAATCGTCACGG&quot; &quot;ACCGTAATCTGGCGTG&quot; ## [520] &quot;ACCTTTAAGAGCTTCT&quot; &quot;ACCTTTAAGTTGTCGT&quot; &quot;ACCTTTACAAGCCCAC&quot; ## [523] &quot;ACCTTTACATGTCCTC&quot; &quot;ACCTTTAGTAGAGTGC&quot; &quot;ACCTTTATCATCTGTT&quot; ## [526] &quot;ACCTTTATCCCTCTTT&quot; &quot;ACCTTTATCCCTGACT&quot; &quot;ACCTTTATCCTGTAGA&quot; ## [529] &quot;ACCTTTATCGCCAGCA&quot; &quot;ACCTTTATCTGCCCTA&quot; &quot;ACCTTTATCTTGACGA&quot; ## [532] &quot;ACGAGCCAGAGCCTAG&quot; &quot;ACGAGCCAGGTGATAT&quot; &quot;ACGAGCCCAAGCCGCT&quot; ## [535] &quot;ACGAGCCCAGGCAGTA&quot; &quot;ACGAGCCGTACCGCTG&quot; &quot;ACGAGCCGTAGAAAGG&quot; ## [538] &quot;ACGAGCCGTTGTCGCG&quot; &quot;ACGAGCCGTTTCGCTC&quot; &quot;ACGAGCCTCACTTCAT&quot; ## [541] &quot;ACGAGCCTCCGTAGGC&quot; &quot;ACGAGCCTCGTCTGAA&quot; &quot;ACGAGCCTCGTGGACC&quot; ## [544] &quot;ACGAGCCTCTTCATGT&quot; &quot;ACGAGGAAGAAGAAGC&quot; &quot;ACGAGGAAGGTGATTA&quot; ## [547] &quot;ACGAGGACACATAACC&quot; &quot;ACGAGGACATGGATGG&quot; &quot;ACGAGGAGTTATCACG&quot; ## [550] &quot;ACGAGGAGTTCGTTGA&quot; &quot;ACGAGGATCCAGGGCT&quot; &quot;ACGAGGATCCCTGACT&quot; ## [553] &quot;ACGAGGATCGAACTGT&quot; &quot;ACGATACAGAAAGTGG&quot; &quot;ACGATACAGACCTAGG&quot; ## [556] &quot;ACGATACAGACTAGAT&quot; &quot;ACGATACCAAACAACA&quot; &quot;ACGATACCAAGCTGGA&quot; ## [559] &quot;ACGATACCACAGGCCT&quot; &quot;ACGATACCAGCCTATA&quot; &quot;ACGATACGTATATCCG&quot; ## [562] &quot;ACGATACGTCAATACC&quot; &quot;ACGATACGTCTTCTCG&quot; &quot;ACGATACGTGCCTTGG&quot; ## [565] &quot;ACGATACGTGCGATAG&quot; &quot;ACGATACGTGGAAAGA&quot; &quot;ACGATACGTTCCAACA&quot; ## [568] &quot;ACGATACTCACATGCA&quot; &quot;ACGATACTCAGCGATT&quot; &quot;ACGATACTCCCAGGTG&quot; ## [571] &quot;ACGATGTAGAGGTACC&quot; &quot;ACGATGTAGATATGCA&quot; &quot;ACGATGTCAAGCGTAG&quot; ## [574] &quot;ACGATGTCAATAGCAA&quot; &quot;ACGATGTCACCAACCG&quot; &quot;ACGATGTCAGGAACGT&quot; ## [577] &quot;ACGATGTCATGTCGAT&quot; &quot;ACGATGTGTAGTAGTA&quot; &quot;ACGATGTGTGACTACT&quot; ## [580] &quot;ACGATGTGTGCACTTA&quot; &quot;ACGATGTGTGCCTGGT&quot; &quot;ACGATGTGTGGTACAG&quot; ## [583] &quot;ACGATGTGTTCAGGCC&quot; &quot;ACGATGTTCCACGAAT&quot; &quot;ACGATGTTCGGTCTAA&quot; ## [586] &quot;ACGATGTTCGTCCGTT&quot; &quot;ACGATGTTCGTTTATC&quot; &quot;ACGATGTTCTCGCTTG&quot; ## [589] &quot;ACGATGTTCTGACCTC&quot; &quot;ACGATGTTCTGTCAAG&quot; &quot;ACGATGTTCTTACCGC&quot; ## [592] &quot;ACGCAGCAGATCTGAA&quot; &quot;ACGCAGCAGATGTGGC&quot; &quot;ACGCAGCAGTGTCTCA&quot; ## [595] &quot;ACGCAGCCAACGATGG&quot; &quot;ACGCAGCCACACGCTG&quot; &quot;ACGCAGCCAGCTGTTA&quot; ## [598] &quot;ACGCAGCCAGGGTTAG&quot; &quot;ACGCAGCGTACTCAAC&quot; &quot;ACGCAGCGTAGGAGTC&quot; ## [601] &quot;ACGCAGCGTATATCCG&quot; &quot;ACGCAGCGTCACCTAA&quot; &quot;ACGCAGCGTCCTCCAT&quot; ## [604] &quot;ACGCAGCGTCTTCTCG&quot; &quot;ACGCAGCGTGTGGTTT&quot; &quot;ACGCAGCGTTCCTCCA&quot; ## [607] &quot;ACGCAGCGTTGTCTTT&quot; &quot;ACGCAGCTCAGGATCT&quot; &quot;ACGCAGCTCGACGGAA&quot; ## [610] &quot;ACGCAGCTCGCCAAAT&quot; &quot;ACGCAGCTCTGATACG&quot; &quot;ACGCCAGAGAACAACT&quot; ## [613] &quot;ACGCCAGAGATGGGTC&quot; &quot;ACGCCAGAGATGTAAC&quot; &quot;ACGCCAGAGCACACAG&quot; ## [616] &quot;ACGCCAGAGGATGTAT&quot; &quot;ACGCCAGAGTAGGTGC&quot; &quot;ACGCCAGAGTCAAGCG&quot; ## [619] &quot;ACGCCAGAGTCTCAAC&quot; &quot;ACGCCAGCAATGCCAT&quot; &quot;ACGCCAGCACACCGCA&quot; ## [622] &quot;ACGCCAGCACGTGAGA&quot; &quot;ACGCCAGCAGCGTCCA&quot; &quot;ACGCCAGGTCAATGTC&quot; ## [625] &quot;ACGCCAGGTCCGAGTC&quot; &quot;ACGCCAGGTCGACTAT&quot; &quot;ACGCCAGGTTCGCTAA&quot; ## [628] &quot;ACGCCAGTCACTCCTG&quot; &quot;ACGCCAGTCAGAGCTT&quot; &quot;ACGCCAGTCATATCGG&quot; ## [631] &quot;ACGCCAGTCCCACTTG&quot; &quot;ACGCCAGTCCTGCCAT&quot; &quot;ACGCCAGTCCTTTCGG&quot; ## [634] &quot;ACGCCAGTCGCAGGCT&quot; &quot;ACGCCAGTCGTTTATC&quot; &quot;ACGCCGAAGACTAGGC&quot; ## [637] &quot;ACGCCGAAGAGGTTAT&quot; &quot;ACGCCGAAGTGTTAGA&quot; &quot;ACGCCGAAGTTACGGG&quot; ## [640] &quot;ACGCCGACAATGTAAG&quot; &quot;ACGCCGACAGACGCCT&quot; &quot;ACGCCGACAGGTTTCA&quot; ## [643] &quot;ACGCCGACATCGGTTA&quot; &quot;ACGCCGAGTCTAACGT&quot; &quot;ACGCCGAGTCTCTTTA&quot; ## [646] &quot;ACGCCGAGTCTTCTCG&quot; &quot;ACGCCGAGTGTAATGA&quot; &quot;ACGCCGAGTTGCGCAC&quot; ## [649] &quot;ACGCCGATCAGGTAAA&quot; &quot;ACGCCGATCATGGTCA&quot; &quot;ACGCCGATCCTACAGA&quot; ## [652] &quot;ACGCCGATCTCGATGA&quot; &quot;ACGCCGATCTTAGAGC&quot; &quot;ACGCCGATCTTCAACT&quot; ## [655] &quot;ACGGAGAAGAGGACGG&quot; &quot;ACGGAGAAGTTCGCGC&quot; &quot;ACGGAGACAAGTTAAG&quot; ## [658] &quot;ACGGAGACAAGTTCTG&quot; &quot;ACGGAGACAATCTACG&quot; &quot;ACGGAGACAGACTCGC&quot; ## [661] &quot;ACGGAGAGTACACCGC&quot; &quot;ACGGAGAGTACTTGAC&quot; &quot;ACGGAGAGTGCTCTTC&quot; ## [664] &quot;ACGGAGAGTGGGTCAA&quot; &quot;ACGGAGAGTGTGACGA&quot; &quot;ACGGAGAGTTCCCGAG&quot; ## [667] &quot;ACGGAGAGTTCGGCAC&quot; &quot;ACGGAGATCAAACAAG&quot; &quot;ACGGAGATCACATACG&quot; ## [670] &quot;ACGGAGATCAGCGACC&quot; &quot;ACGGAGATCATCTGCC&quot; &quot;ACGGAGATCGAACGGA&quot; ## [673] &quot;ACGGCCAAGACCTAGG&quot; &quot;ACGGCCAAGCGAAGGG&quot; &quot;ACGGCCAAGCTGAAAT&quot; ## [676] &quot;ACGGCCAAGGATCGCA&quot; &quot;ACGGCCACAACGATCT&quot; &quot;ACGGCCACACACTGCG&quot; ## [679] &quot;ACGGCCACACGAGAGT&quot; &quot;ACGGCCACACGGATAG&quot; &quot;ACGGCCACACTCTGTC&quot; ## [682] &quot;ACGGCCACAGTAAGAT&quot; &quot;ACGGCCAGTCAACATC&quot; &quot;ACGGCCAGTGAGTGAC&quot; ## [685] &quot;ACGGCCATCACTTATC&quot; &quot;ACGGCCATCATAAAGG&quot; &quot;ACGGCCATCCAAAGTC&quot; ## [688] &quot;ACGGCCATCCGAGCCA&quot; &quot;ACGGCCATCGGAATCT&quot; &quot;ACGGCCATCGTCACGG&quot; ## [691] &quot;ACGGCCATCTGCCCTA&quot; &quot;ACGGGCTAGCCCAACC&quot; &quot;ACGGGCTAGGGTATCG&quot; ## [694] &quot;ACGGGCTAGGGTGTTG&quot; &quot;ACGGGCTCACACCGAC&quot; &quot;ACGGGCTCACCCATTC&quot; ## [697] &quot;ACGGGCTCATGTAGTC&quot; &quot;ACGGGCTCATGTCGAT&quot; &quot;ACGGGCTGTTCAACCA&quot; ## [700] &quot;ACGGGCTTCAACCAAC&quot; &quot;ACGGGCTTCAACCATG&quot; &quot;ACGGGCTTCTCTTGAT&quot; ## [703] &quot;ACGGGTCAGATGCCAG&quot; &quot;ACGGGTCAGCACACAG&quot; &quot;ACGGGTCCAGCTGTGC&quot; ## [706] &quot;ACGGGTCGTATAGGTA&quot; &quot;ACGGGTCGTTGGAGGT&quot; &quot;ACGGGTCTCATGCATG&quot; ## [709] &quot;ACGGGTCTCATGGTCA&quot; &quot;ACGGGTCTCTCAAACG&quot; &quot;ACGGGTCTCTGGCGTG&quot; ## [712] &quot;ACGTCAAAGCAATCTC&quot; &quot;ACGTCAAAGTCTTGCA&quot; &quot;ACGTCAAAGTGGGTTG&quot; ## [715] &quot;ACGTCAACAATCGGTT&quot; &quot;ACGTCAAGTCGAATCT&quot; &quot;ACGTCAAGTGAGTGAC&quot; ## [718] &quot;ACGTCAAGTGCACCAC&quot; &quot;ACGTCAATCACGAAGG&quot; &quot;ACGTCAATCAGTGCAT&quot; ## [721] &quot;ACGTCAATCAGTTGAC&quot; &quot;ACGTCAATCATCGGAT&quot; &quot;ACGTCAATCCAAAGTC&quot; ## [724] &quot;ACGTCAATCCGAAGAG&quot; &quot;ACGTCAATCTAACTTC&quot; &quot;ACGTCAATCTGATACG&quot; ## [727] &quot;ACGTCAATCTGCCCTA&quot; &quot;ACTATCTAGCAACGGT&quot; &quot;ACTATCTAGTAGCGGT&quot; ## [730] &quot;ACTATCTCAATGCCAT&quot; &quot;ACTATCTCAGATAATG&quot; &quot;ACTATCTCATAGACTC&quot; ## [733] &quot;ACTATCTCATTCGACA&quot; &quot;ACTATCTGTGTAATGA&quot; &quot;ACTATCTGTTGGTGGA&quot; ## [736] &quot;ACTATCTTCACGCATA&quot; &quot;ACTATCTTCAGCACAT&quot; &quot;ACTATCTTCATGTCTT&quot; ## [739] &quot;ACTGAACAGAAGGACA&quot; &quot;ACTGAACAGGGTCTCC&quot; &quot;ACTGAACCAATGAAAC&quot; ## [742] &quot;ACTGAACCACGCCAGT&quot; &quot;ACTGAACCACTTCTGC&quot; &quot;ACTGAACCAGCTGCAC&quot; ## [745] &quot;ACTGAACCAGGCTCAC&quot; &quot;ACTGAACGTACTTAGC&quot; &quot;ACTGAACGTATGGTTC&quot; ## [748] &quot;ACTGAACGTTCGCGAC&quot; &quot;ACTGAACGTTTGCATG&quot; &quot;ACTGAACTCACAAACC&quot; ## [751] &quot;ACTGAACTCCATGCTC&quot; &quot;ACTGAGTAGAAGAAGC&quot; &quot;ACTGAGTAGCACCGCT&quot; ## [754] &quot;ACTGAGTAGGAGTACC&quot; &quot;ACTGAGTAGGCATGGT&quot; &quot;ACTGAGTCAACTGGCC&quot; ## [757] &quot;ACTGAGTCACACCGAC&quot; &quot;ACTGAGTCATAGAAAC&quot; &quot;ACTGAGTCATATGGTC&quot; ## [760] &quot;ACTGAGTCATCCGTGG&quot; &quot;ACTGAGTGTCAACTGT&quot; &quot;ACTGAGTGTCAGAAGC&quot; ## [763] &quot;ACTGAGTGTGGACGAT&quot; &quot;ACTGAGTGTGTGACCC&quot; &quot;ACTGAGTTCGGTCCGA&quot; ## [766] &quot;ACTGATGAGAAACGAG&quot; &quot;ACTGATGAGACAAGCC&quot; &quot;ACTGATGAGCGATGAC&quot; ## [769] &quot;ACTGATGAGGTAAACT&quot; &quot;ACTGATGAGTAACCCT&quot; &quot;ACTGATGCACTCGACG&quot; ## [772] &quot;ACTGATGCAGGTCTCG&quot; &quot;ACTGATGGTCTCTCGT&quot; &quot;ACTGATGGTTCACCTC&quot; ## [775] &quot;ACTGATGGTTCTGAAC&quot; &quot;ACTGATGTCCAGGGCT&quot; &quot;ACTGATGTCCGCGGTA&quot; ## [778] &quot;ACTGATGTCTCGCATC&quot; &quot;ACTGCTCAGTTACGGG&quot; &quot;ACTGCTCCAAACTGTC&quot; ## [781] &quot;ACTGCTCCAAGTTCTG&quot; &quot;ACTGCTCCACCTCGTT&quot; &quot;ACTGCTCCACTTGGAT&quot; ## [784] &quot;ACTGCTCCAGCAGTTT&quot; &quot;ACTGCTCGTGGTCCGT&quot; &quot;ACTGCTCTCAGAGGTG&quot; ## [787] &quot;ACTGCTCTCCCGGATG&quot; &quot;ACTGCTCTCCGCGCAA&quot; &quot;ACTGCTCTCTGAGTGT&quot; ## [790] &quot;ACTGTCCAGACAGACC&quot; &quot;ACTGTCCAGAGATGAG&quot; &quot;ACTGTCCAGGGAACGG&quot; ## [793] &quot;ACTGTCCAGTTGTCGT&quot; &quot;ACTGTCCCACCTATCC&quot; &quot;ACTGTCCCAGCATGAG&quot; ## [796] &quot;ACTGTCCGTCAGCTAT&quot; &quot;ACTGTCCGTCCGTGAC&quot; &quot;ACTGTCCTCATTGCCC&quot; ## [799] &quot;ACTGTCCTCGAACTGT&quot; &quot;ACTGTCCTCTAACTGG&quot; &quot;ACTTACTAGAGGTAGA&quot; ## [802] &quot;ACTTACTAGTCTTGCA&quot; &quot;ACTTACTAGTGTCCAT&quot; &quot;ACTTACTCAAGCTGAG&quot; ## [805] &quot;ACTTACTCACATCCAA&quot; &quot;ACTTACTCACGGTAAG&quot; &quot;ACTTACTGTAAACGCG&quot; ## [808] &quot;ACTTACTGTAGCCTAT&quot; &quot;ACTTACTGTCAAAGAT&quot; &quot;ACTTACTGTTTGACAC&quot; ## [811] &quot;ACTTACTTCACAGTAC&quot; &quot;ACTTACTTCAGGCGAA&quot; &quot;ACTTACTTCATCACCC&quot; ## [814] &quot;ACTTGTTAGCGCTCCA&quot; &quot;ACTTGTTAGGCACATG&quot; &quot;ACTTGTTAGGTGCAAC&quot; ## [817] &quot;ACTTGTTCAATGGTCT&quot; &quot;ACTTGTTCACGCTTTC&quot; &quot;ACTTGTTCACGTCTCT&quot; ## [820] &quot;ACTTGTTCAGACGCTC&quot; &quot;ACTTGTTCAGTCAGAG&quot; &quot;ACTTGTTCATCCCACT&quot; ## [823] &quot;ACTTGTTCATCCCATC&quot; &quot;ACTTGTTCATGAACCT&quot; &quot;ACTTGTTGTCCGAGTC&quot; ## [826] &quot;ACTTGTTGTCGAATCT&quot; &quot;ACTTGTTGTCGAGATG&quot; &quot;ACTTGTTGTCTCTCTG&quot; ## [829] &quot;ACTTGTTGTGCTGTAT&quot; &quot;ACTTGTTGTTGGGACA&quot; &quot;ACTTGTTGTTGTCTTT&quot; ## [832] &quot;ACTTGTTTCCACTCCA&quot; &quot;ACTTTCAAGCAGCGTA&quot; &quot;ACTTTCAAGCGTTTAC&quot; ## [835] &quot;ACTTTCAAGCTAGGCA&quot; &quot;ACTTTCAAGCTCCTTC&quot; &quot;ACTTTCACAAACGCGA&quot; ## [838] &quot;ACTTTCACAGACTCGC&quot; &quot;ACTTTCACAGTCAGCC&quot; &quot;ACTTTCACATTGTGCA&quot; ## [841] &quot;ACTTTCAGTACTTAGC&quot; &quot;ACTTTCAGTACTTCTT&quot; &quot;ACTTTCAGTCTAAACC&quot; ## [844] &quot;ACTTTCAGTGTAACGG&quot; &quot;ACTTTCATCAACACGT&quot; &quot;ACTTTCATCCACGTTC&quot; ## [847] &quot;AGAATAGAGATGTTAG&quot; &quot;AGAATAGAGCCAGGAT&quot; &quot;AGAATAGAGCTCAACT&quot; ## [850] &quot;AGAATAGAGGAGTACC&quot; &quot;AGAATAGAGGTAAACT&quot; &quot;AGAATAGAGGTCGGAT&quot; ## [853] &quot;AGAATAGAGTGGGTTG&quot; &quot;AGAATAGCAACGCACC&quot; &quot;AGAATAGCAAGGTGTG&quot; ## [856] &quot;AGAATAGCACATGACT&quot; &quot;AGAATAGCACCCAGTG&quot; &quot;AGAATAGCATAAAGGT&quot; ## [859] &quot;AGAATAGCATAGAAAC&quot; &quot;AGAATAGCATGCCTTC&quot; &quot;AGAATAGGTACTTAGC&quot; ## [862] &quot;AGAATAGGTTCAGACT&quot; &quot;AGAATAGTCACCTCGT&quot; &quot;AGAATAGTCAGCTCTC&quot; ## [865] &quot;AGAATAGTCCTATTCA&quot; &quot;AGACGTTAGACTGGGT&quot; &quot;AGACGTTAGGCCCTCA&quot; ## [868] &quot;AGACGTTAGGTAAACT&quot; &quot;AGACGTTAGTGTTTGC&quot; &quot;AGACGTTCAGCTCCGA&quot; ## [871] &quot;AGACGTTGTAGGACAC&quot; &quot;AGACGTTGTGGTACAG&quot; &quot;AGACGTTTCAGTTAGC&quot; ## [874] &quot;AGACGTTTCCGTACAA&quot; &quot;AGACGTTTCTGCAAGT&quot; &quot;AGACGTTTCTTCCTTC&quot; ## [877] &quot;AGAGCGAAGATCCCGC&quot; &quot;AGAGCGAAGATCCTGT&quot; &quot;AGAGCGAAGCAGATCG&quot; ## [880] &quot;AGAGCGAAGTCCGGTC&quot; &quot;AGAGCGACAAAGCAAT&quot; &quot;AGAGCGACAATGGAAT&quot; ## [883] &quot;AGAGCGACATATGCTG&quot; &quot;AGAGCGACATCACAAC&quot; &quot;AGAGCGACATGGAATA&quot; ## [886] &quot;AGAGCGAGTACGACCC&quot; &quot;AGAGCGAGTCATGCAT&quot; &quot;AGAGCGAGTTGTACAC&quot; ## [889] &quot;AGAGCGATCACCGTAA&quot; &quot;AGAGCGATCAGCTTAG&quot; &quot;AGAGCGATCGGCGGTT&quot; ## [892] &quot;AGAGCGATCGGCTTGG&quot; &quot;AGAGCGATCTGTCTCG&quot; &quot;AGAGCTTAGACTAGGC&quot; ## [895] &quot;AGAGCTTAGCCACGTC&quot; &quot;AGAGCTTAGTCGTTTG&quot; &quot;AGAGCTTAGTGGGCTA&quot; ## [898] &quot;AGAGCTTCAAGTACCT&quot; &quot;AGAGCTTCACAGCCCA&quot; &quot;AGAGCTTCACCCAGTG&quot; ## [901] &quot;AGAGCTTCACGCTTTC&quot; &quot;AGAGCTTCAGTATCTG&quot; &quot;AGAGCTTCATAGTAAG&quot; ## [904] &quot;AGAGCTTGTCTAAACC&quot; &quot;AGAGCTTGTGCTAGCC&quot; &quot;AGAGCTTGTGGCAAAC&quot; ## [907] &quot;AGAGCTTGTGGTACAG&quot; &quot;AGAGCTTTCACTATTC&quot; &quot;AGAGCTTTCAGAAATG&quot; ## [910] &quot;AGAGCTTTCAGCACAT&quot; &quot;AGAGCTTTCCTCGCAT&quot; &quot;AGAGTGGAGAGGTAGA&quot; ## [913] &quot;AGAGTGGAGCCCGAAA&quot; &quot;AGAGTGGAGTCATGCT&quot; &quot;AGAGTGGAGTGGTCCC&quot; ## [916] &quot;AGAGTGGAGTGTACGG&quot; &quot;AGAGTGGCACATAACC&quot; &quot;AGAGTGGCACCGAAAG&quot; ## [919] &quot;AGAGTGGCAGCGTTCG&quot; &quot;AGAGTGGCAGGACCCT&quot; &quot;AGAGTGGCATCGATTG&quot; ## [922] &quot;AGAGTGGGTAGTGAAT&quot; &quot;AGAGTGGGTATAATGG&quot; &quot;AGAGTGGTCCCGACTT&quot; ## [925] &quot;AGAGTGGTCTACTTAC&quot; &quot;AGAGTGGTCTGTCAAG&quot; &quot;AGATCTGAGAGGTAGA&quot; ## [928] &quot;AGATCTGAGCAGGTCA&quot; &quot;AGATCTGAGCCAACAG&quot; &quot;AGATCTGAGGATCGCA&quot; ## [931] &quot;AGATCTGAGGGATCTG&quot; &quot;AGATCTGAGGGCTCTC&quot; &quot;AGATCTGAGGTGATAT&quot; ## [934] &quot;AGATCTGAGTACGTAA&quot; &quot;AGATCTGAGTTCGCAT&quot; &quot;AGATCTGCAAACAACA&quot; ## [937] &quot;AGATCTGCACATGACT&quot; &quot;AGATCTGGTAAGAGGA&quot; &quot;AGATCTGTCAGTTCGA&quot; ## [940] &quot;AGATCTGTCGCCATAA&quot; &quot;AGATCTGTCGCTTAGA&quot; &quot;AGATTGCAGAAACCAT&quot; ## [943] &quot;AGATTGCAGAGGTACC&quot; &quot;AGATTGCAGATAGTCA&quot; &quot;AGATTGCCACGGTTTA&quot; ## [946] &quot;AGATTGCCAGGGTATG&quot; &quot;AGATTGCCATCACGTA&quot; &quot;AGATTGCGTACATGTC&quot; ## [949] &quot;AGATTGCGTCCAGTAT&quot; &quot;AGATTGCGTCCGTGAC&quot; &quot;AGATTGCTCAGTGCAT&quot; ## [952] &quot;AGATTGCTCATGCATG&quot; &quot;AGATTGCTCGGCGGTT&quot; &quot;AGCAGCCAGAAACCAT&quot; ## [955] &quot;AGCAGCCAGACCTTTG&quot; &quot;AGCAGCCAGACGACGT&quot; &quot;AGCAGCCAGATGTTAG&quot; ## [958] &quot;AGCAGCCAGCACCGTC&quot; &quot;AGCAGCCAGTGGTAAT&quot; &quot;AGCAGCCCAAACCCAT&quot; ## [961] &quot;AGCAGCCCAGATGGCA&quot; &quot;AGCAGCCCATCACGAT&quot; &quot;AGCAGCCGTACTTAGC&quot; ## [964] &quot;AGCAGCCGTCCGAAGA&quot; &quot;AGCAGCCGTCGCTTCT&quot; &quot;AGCAGCCGTGCAGTAG&quot; ## [967] &quot;AGCAGCCGTTCCCGAG&quot; &quot;AGCAGCCGTTTAGGAA&quot; &quot;AGCAGCCGTTTGTTTC&quot; ## [970] &quot;AGCAGCCTCCTTGCCA&quot; &quot;AGCAGCCTCGTCGTTC&quot; &quot;AGCAGCCTCTGGAGCC&quot; ## [973] &quot;AGCATACAGTTCGATC&quot; &quot;AGCATACCACCACGTG&quot; &quot;AGCATACCACGGATAG&quot; ## [976] &quot;AGCATACCAGCTATTG&quot; &quot;AGCATACGTCCTCTTG&quot; &quot;AGCATACGTTAAGGGC&quot; ## [979] &quot;AGCATACGTTACTGAC&quot; &quot;AGCATACGTTAGATGA&quot; &quot;AGCATACTCATCGCTC&quot; ## [982] &quot;AGCATACTCCGCATCT&quot; &quot;AGCATACTCGAACTGT&quot; &quot;AGCATACTCTAACTTC&quot; ## [985] &quot;AGCATACTCTCGGACG&quot; &quot;AGCCTAAAGCCCAATT&quot; &quot;AGCCTAAAGGACATTA&quot; ## [988] &quot;AGCCTAAAGTACGTTC&quot; &quot;AGCCTAAAGTCGATAA&quot; &quot;AGCCTAAAGTCTTGCA&quot; ## [991] &quot;AGCCTAACAAGCCTAT&quot; &quot;AGCCTAACACGTCTCT&quot; &quot;AGCCTAACAGCCTGTG&quot; ## [994] &quot;AGCCTAACATCAGTCA&quot; &quot;AGCCTAAGTATCTGCA&quot; &quot;AGCCTAAGTCGGCTCA&quot; ## [997] &quot;AGCCTAAGTTATCCGA&quot; &quot;AGCCTAATCAGTACGT&quot; &quot;AGCCTAATCCCTTGTG&quot; ## [1000] &quot;AGCCTAATCGTTTGCC&quot; ## [ reached getOption(&quot;max.print&quot;) -- omitted 6109 entries ] # One can pull multiple values from the data frame at any time head(x = seurat@meta.data[c(&#39;nCount_RNA&#39;, &#39;nFeature_RNA&#39;)]) ## nCount_RNA nFeature_RNA ## AAACCTGAGCTAGTCT 3605 1184 ## AAACCTGAGGGCACTA 3828 1387 ## AAACCTGAGTACGTTC 6457 1784 ## AAACCTGAGTCCGGTC 3075 1092 ## AAACCTGCACCAGGTC 9399 2625 ## AAACCTGCACCTCGTT 48838 5602 # The $ sigil can only pull bit of meta data at a time; however, tab-autocompletion # has been enabled for the $ sigil, making it ideal for interactive use head(x = seurat@meta.data$nFeature_RNA) ## [1] 1184 1387 1784 1092 2625 5602 # Passing `drop = TRUE` will turn the meta data into a names vector # with each entry being named for the cell it corresponds to head(x = seurat@meta.data[&#39;nFeature_RNA&#39;, drop = TRUE]) ## Warning in `[.data.frame`(seurat@meta.data, &quot;nFeature_RNA&quot;, drop ## = TRUE): &#39;drop&#39; argument will be ignored ## nFeature_RNA ## AAACCTGAGCTAGTCT 1184 ## AAACCTGAGGGCACTA 1387 ## AAACCTGAGTACGTTC 1784 ## AAACCTGAGTCCGGTC 1092 ## AAACCTGCACCAGGTC 2625 ## AAACCTGCACCTCGTT 5602 # Add meta data example 4.4.1.4 Methods Methods for the Seurat class can be found with the following: utils::methods(class = &#39;Seurat&#39;) ## [1] [ [[ ## [3] [[&lt;- $ ## [5] $&lt;- AddMetaData ## [7] as.CellDataSet as.loom ## [9] as.SingleCellExperiment colMeans ## [11] colSums Command ## [13] DefaultAssay DefaultAssay&lt;- ## [15] dim dimnames ## [17] droplevels Embeddings ## [19] FindClusters FindMarkers ## [21] FindNeighbors FindVariableFeatures ## [23] GetAssay GetAssayData ## [25] HVFInfo Idents ## [27] Idents&lt;- Key ## [29] levels levels&lt;- ## [31] Loadings merge ## [33] Misc Misc&lt;- ## [35] names NormalizeData ## [37] OldWhichCells Project ## [39] Project&lt;- RenameCells ## [41] RenameIdents ReorderIdent ## [43] rowMeans rowSums ## [45] RunALRA RunCCA ## [47] RunICA RunLSI ## [49] RunPCA RunTSNE ## [51] RunUMAP ScaleData ## [53] ScoreJackStraw SetAssayData ## [55] SetIdent show ## [57] StashIdent Stdev ## [59] subset SubsetData ## [61] Tool Tool&lt;- ## [63] VariableFeatures VariableFeatures&lt;- ## [65] WhichCells ## see &#39;?methods&#39; for accessing help and source code You can also list all functions in the Seurat package by using: ls(&quot;package:Seurat&quot;) ## [1] &quot;AddMetaData&quot; ## [2] &quot;AddModuleScore&quot; ## [3] &quot;ALRAChooseKPlot&quot; ## [4] &quot;as.CellDataSet&quot; ## [5] &quot;as.Graph&quot; ## [6] &quot;as.loom&quot; ## [7] &quot;as.Seurat&quot; ## [8] &quot;as.SingleCellExperiment&quot; ## [9] &quot;as.sparse&quot; ## [10] &quot;Assays&quot; ## [11] &quot;AugmentPlot&quot; ## [12] &quot;AverageExpression&quot; ## [13] &quot;BarcodeInflectionsPlot&quot; ## [14] &quot;BlackAndWhite&quot; ## [15] &quot;BlueAndRed&quot; ## [16] &quot;BoldTitle&quot; ## [17] &quot;BuildClusterTree&quot; ## [18] &quot;CalculateBarcodeInflections&quot; ## [19] &quot;CaseMatch&quot; ## [20] &quot;cc.genes&quot; ## [21] &quot;cc.genes.updated.2019&quot; ## [22] &quot;CellCycleScoring&quot; ## [23] &quot;Cells&quot; ## [24] &quot;CellsByIdentities&quot; ## [25] &quot;CellScatter&quot; ## [26] &quot;CellSelector&quot; ## [27] &quot;CollapseEmbeddingOutliers&quot; ## [28] &quot;CollapseSpeciesExpressionMatrix&quot; ## [29] &quot;ColorDimSplit&quot; ## [30] &quot;CombinePlots&quot; ## [31] &quot;Command&quot; ## [32] &quot;CreateAssayObject&quot; ## [33] &quot;CreateDimReducObject&quot; ## [34] &quot;CreateGeneActivityMatrix&quot; ## [35] &quot;CreateSeuratObject&quot; ## [36] &quot;CustomDistance&quot; ## [37] &quot;CustomPalette&quot; ## [38] &quot;DarkTheme&quot; ## [39] &quot;DefaultAssay&quot; ## [40] &quot;DefaultAssay&lt;-&quot; ## [41] &quot;DietSeurat&quot; ## [42] &quot;DimHeatmap&quot; ## [43] &quot;DimPlot&quot; ## [44] &quot;DoHeatmap&quot; ## [45] &quot;DotPlot&quot; ## [46] &quot;ElbowPlot&quot; ## [47] &quot;Embeddings&quot; ## [48] &quot;ExpMean&quot; ## [49] &quot;ExportToCellbrowser&quot; ## [50] &quot;ExpSD&quot; ## [51] &quot;ExpVar&quot; ## [52] &quot;FeatureLocator&quot; ## [53] &quot;FeaturePlot&quot; ## [54] &quot;FeatureScatter&quot; ## [55] &quot;FetchData&quot; ## [56] &quot;FindAllMarkers&quot; ## [57] &quot;FindClusters&quot; ## [58] &quot;FindConservedMarkers&quot; ## [59] &quot;FindIntegrationAnchors&quot; ## [60] &quot;FindMarkers&quot; ## [61] &quot;FindNeighbors&quot; ## [62] &quot;FindTransferAnchors&quot; ## [63] &quot;FindVariableFeatures&quot; ## [64] &quot;FontSize&quot; ## [65] &quot;GeneSymbolThesarus&quot; ## [66] &quot;GetAssay&quot; ## [67] &quot;GetAssayData&quot; ## [68] &quot;GetIntegrationData&quot; ## [69] &quot;GetResidual&quot; ## [70] &quot;HoverLocator&quot; ## [71] &quot;HTODemux&quot; ## [72] &quot;HTOHeatmap&quot; ## [73] &quot;HVFInfo&quot; ## [74] &quot;Idents&quot; ## [75] &quot;Idents&lt;-&quot; ## [76] &quot;IntegrateData&quot; ## [77] &quot;IsGlobal&quot; ## [78] &quot;JackStraw&quot; ## [79] &quot;JackStrawPlot&quot; ## [80] &quot;JS&quot; ## [81] &quot;JS&lt;-&quot; ## [82] &quot;Key&quot; ## [83] &quot;Key&lt;-&quot; ## [84] &quot;L2CCA&quot; ## [85] &quot;L2Dim&quot; ## [86] &quot;LabelClusters&quot; ## [87] &quot;LabelPoints&quot; ## [88] &quot;Loadings&quot; ## [89] &quot;Loadings&lt;-&quot; ## [90] &quot;LocalStruct&quot; ## [91] &quot;LogNormalize&quot; ## [92] &quot;LogSeuratCommand&quot; ## [93] &quot;LogVMR&quot; ## [94] &quot;MetaFeature&quot; ## [95] &quot;MinMax&quot; ## [96] &quot;Misc&quot; ## [97] &quot;Misc&lt;-&quot; ## [98] &quot;MixingMetric&quot; ## [99] &quot;MULTIseqDemux&quot; ## [100] &quot;NoAxes&quot; ## [101] &quot;NoGrid&quot; ## [102] &quot;NoLegend&quot; ## [103] &quot;NormalizeData&quot; ## [104] &quot;OldWhichCells&quot; ## [105] &quot;pbmc_small&quot; ## [106] &quot;PCAPlot&quot; ## [107] &quot;PCASigGenes&quot; ## [108] &quot;PCHeatmap&quot; ## [109] &quot;PercentageFeatureSet&quot; ## [110] &quot;PlotClusterTree&quot; ## [111] &quot;PolyDimPlot&quot; ## [112] &quot;PolyFeaturePlot&quot; ## [113] &quot;PrepSCTIntegration&quot; ## [114] &quot;Project&quot; ## [115] &quot;Project&lt;-&quot; ## [116] &quot;ProjectDim&quot; ## [117] &quot;PurpleAndYellow&quot; ## [118] &quot;Read10X&quot; ## [119] &quot;Read10X_h5&quot; ## [120] &quot;ReadAlevin&quot; ## [121] &quot;ReadAlevinCsv&quot; ## [122] &quot;ReadH5AD&quot; ## [123] &quot;Reductions&quot; ## [124] &quot;RegroupIdents&quot; ## [125] &quot;RelativeCounts&quot; ## [126] &quot;RenameAssays&quot; ## [127] &quot;RenameCells&quot; ## [128] &quot;RenameIdents&quot; ## [129] &quot;ReorderIdent&quot; ## [130] &quot;RestoreLegend&quot; ## [131] &quot;RidgePlot&quot; ## [132] &quot;RotatedAxis&quot; ## [133] &quot;RowMergeSparseMatrices&quot; ## [134] &quot;RunALRA&quot; ## [135] &quot;RunCCA&quot; ## [136] &quot;RunICA&quot; ## [137] &quot;RunLSI&quot; ## [138] &quot;RunPCA&quot; ## [139] &quot;RunTSNE&quot; ## [140] &quot;RunUMAP&quot; ## [141] &quot;SampleUMI&quot; ## [142] &quot;ScaleData&quot; ## [143] &quot;ScoreJackStraw&quot; ## [144] &quot;SCTransform&quot; ## [145] &quot;SelectIntegrationFeatures&quot; ## [146] &quot;SetAssayData&quot; ## [147] &quot;SetIdent&quot; ## [148] &quot;SetIntegrationData&quot; ## [149] &quot;SeuratAxes&quot; ## [150] &quot;SeuratTheme&quot; ## [151] &quot;SpatialTheme&quot; ## [152] &quot;SplitObject&quot; ## [153] &quot;StashIdent&quot; ## [154] &quot;Stdev&quot; ## [155] &quot;StopCellbrowser&quot; ## [156] &quot;SubsetByBarcodeInflections&quot; ## [157] &quot;SubsetData&quot; ## [158] &quot;TF.IDF&quot; ## [159] &quot;Tool&quot; ## [160] &quot;Tool&lt;-&quot; ## [161] &quot;TopCells&quot; ## [162] &quot;TopFeatures&quot; ## [163] &quot;TransferData&quot; ## [164] &quot;TSNEPlot&quot; ## [165] &quot;UMAPPlot&quot; ## [166] &quot;UpdateSeuratObject&quot; ## [167] &quot;UpdateSymbolList&quot; ## [168] &quot;VariableFeaturePlot&quot; ## [169] &quot;VariableFeatures&quot; ## [170] &quot;VariableFeatures&lt;-&quot; ## [171] &quot;VizDimLoadings&quot; ## [172] &quot;VlnPlot&quot; ## [173] &quot;WhichCells&quot; ## [174] &quot;WhiteBackground&quot; 4.5 Preprocessing step 1 : Filter out low-quality cells The Seurat object initialization step above only considered cells that expressed at least 350 genes. Additionally, we would like to exclude cells that are damaged. A common metric to judge this (although by no means the only one) is the relative expression of mitochondrially derived genes. When the cells apoptose due to stress, their mitochondria becomes leaky and there is widespread RNA degradation. Thus a relative enrichment of mitochondrially derived genes can be a tell-tale sign of cell stress. Here, we compute the proportion of transcripts that are of mitochondrial origin for every cell (percent.mt), and visualize its distribution as a violin plot. We also use the FeatureScatter function to observe how percent.mt correlates with other metrics. # The number of genes and UMIs (nFeature_RNA nCount_RNA) are automatically calculated # for every object by Seurat. For non-UMI data, nCount_RNA represents the sum of # the non-normalized values within a cell We calculate the percentage of # mitochondrial genes here and store it in percent.mt using AddMetaData. # We use GetAssayData(object = seurat, slot = &#39;data&#39;) since this represents non-transformed and # non-log-normalized counts The % of UMI mapping to MT-genes is a common # scRNA-seq QC metric. # The [[ operator can add columns to object metadata. This is a great place to stash QC stats seurat[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(object = seurat, pattern = &quot;^MT-&quot;) # PercentageFeatureSet adds columns to object@meta.data, and is a great place to stash QC stats. # This also allows us to plot the metadata values using the Seurat&#39;s VlnPlot(). head(seurat@meta.data) # Before adding ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCTGAGCTAGTCT 10X_NSCLC 3605 1184 20.832178 ## AAACCTGAGGGCACTA 10X_NSCLC 3828 1387 3.448276 ## AAACCTGAGTACGTTC 10X_NSCLC 6457 1784 2.865108 ## AAACCTGAGTCCGGTC 10X_NSCLC 3075 1092 6.276423 ## AAACCTGCACCAGGTC 10X_NSCLC 9399 2625 3.202468 ## AAACCTGCACCTCGTT 10X_NSCLC 48838 5602 2.321962 VlnPlot(object = seurat, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) Here we calculated the percent mitochondrial reads and added it to the Seurat object in the slot named meta.data. This allowed us to plot using the violin plot function provided by Seurat. A third metric we use is the number of house keeping genes expressed in a cell. These genes reflect commomn processes active in a cell and hence are a good global quality measure. They are also abundant and are usually steadliy expressed in cells, thus less sensitive to the high dropout. # Load the the list of house keeping genes hkgenes &lt;- read.table(paste0(dirname, &quot;housekeepers.txt&quot;), skip = 2) hkgenes &lt;- as.vector(hkgenes$V1) # remove hkgenes that were not found hkgenes.found &lt;- which(toupper(rownames(seurat@assays$RNA@data)) %in% hkgenes) Possible task: Feel like challenging yourself? write the code to do the following: 1. Sum the number of detected house keeping genes for each cell 2. Add this information as meta data to seurat 3. plot all metrics: “nFeature_RNA”, “nCount_RNA”, “percent.mt”,“n.exp.hkgenes” using VlnPlot 4. Scroll down to see if you got it! If you feel like going through a more guided version, scroll down and follow the instructions. Alternative task: Sum the number of detected house keeping genes for each cell, then add this to the meta data #### n.expressed.hkgenes &lt;- ?(seurat@data[hkgenes.found, ] &gt; ?) #### seurat &lt;- AddMetaData(object = ?, ? = ?, col.name = &quot;n.exp.hkgenes&quot;) n.expressed.hkgenes &lt;- Matrix::colSums(seurat@assays$RNA@data[hkgenes.found, ] &gt; 0) seurat &lt;- AddMetaData(object = seurat, metadata = n.expressed.hkgenes, col.name = &quot;n.exp.hkgenes&quot;) VlnPlot(object = seurat, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;, &quot;n.exp.hkgenes&quot;), ncol = 2) Is there a correlation between the measurements? For example, number of UMIs with number of genes? Possible task: Feel like challenging yourself? write the code to do the following: Can you plot the nGene vs nUMI (hint:GenePlot)? What is the correlation? Do you see a strange subpopulation? What do you think happened with these cells? seurat Scroll down to see the command Alternative task: Can you plot the nFeature_RNA vs nCount_RNA (hint:FeatureScatter)? What is the correlation? Do you see a strange subpopulation? What do you think happened with these cells? # FeatureScatter is typically used to visualize feature-feature relationships, but can be used # for anything calculated by the object, i.e. columns in object metadata, PC scores etc. plot1 &lt;- FeatureScatter(seurat, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(seurat, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) CombinePlots(plots = list(plot1, plot2)) ### FeatureScatter(object = seurat, feature1 = ?, feature2 = ?) ## could be genes or meta data columns FeatureScatter(object = seurat, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) 4.6 Examine contents of Seurat object str(seurat) These are the slots in the Seurat object. Some of the slots are automatically updated by Seurat as you move through analysis. Take a moment to look through the information, knowing the slots allow you to leverage work Seurat has already done for you. VlnPlot(object = seurat, features = c(&quot;nFeature_RNA&quot;), group.by = c(&#39;orig.ident&#39;)) Here we plot the number of genes per cell by what Seurat calls orig.ident. Identity is a concept that is used in the Seurat object to refer to the cell identity. In this case, the cell identity is 10X_NSCLC, but after we cluster the cells, the cell identity will be whatever cluster the cell belongs to. We will see how identity updates as we go throught the analysis. Next, let’s filter the cells based on the quality control metrics. Filter based on: 1. nFeature_RNA 2. percent.mt 3. n.exp.hkgenes Task: Change the thresholds to what you think they should be according to the violin plots VlnPlot(object = seurat, features = c(&quot;nFeature_RNA&quot;,&quot;percent.mt&quot;,&quot;n.exp.hkgenes&quot;), ncol = 3) # seurat &lt;- SubsetData(object = seurat, subset.names = c(&quot;nFeature_RNA&quot;, &quot;percent.mito&quot;,&quot;n.exp.hkgenes&quot;), low.thresholds = c(350, -Inf,55), high.thresholds = c(5000, 0.1, Inf)) seurat &lt;- subset(seurat, nFeature_RNA &lt; 5000) seurat &lt;- subset(seurat, nFeature_RNA &gt; 350) seuart &lt;- subset(seurat, n.exp.hkgenes &gt; 55) seuart &lt;- subset(seurat, percent.mt &lt; 10) How many cells are you left with? seurat 4.6.1 Preprocessing step 2 : Expression normalization After removing unwanted genes cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method “LogNormalize” that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. There have been many methods to normalize the data, but this is the simplest and the most intuitive. The division by total expression is done to change all expression counts to a relative measure, since experience has suggested that technical factors (e.g. capture rate, efficiency of reverse transcription) are largely responsible for the variation in the number of molecules per cell, although genuine biological factors (e.g. cell cycle stage, cell size) also play a smaller, but non-negligible role. The log-transformation is a commonly used transformation that has many desirable properties, such as variance stabilization (can you think of others?). seurat &lt;- NormalizeData(object = seurat, normalization.method = &quot;LogNormalize&quot;, scale.factor = 1e4) Well there you have it! A filtered and normalized gene-expression data set. A great accomplishment for your first dive into scRNA-Seq analysis. Well done! 4.7 Detection of variable genes across the single cells Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableFeatures calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. This function is unchanged from (Macosko et al.), but new methods for variable gene expression identification are coming soon. We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters here identify ~3,000 variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules. ### seurat &lt;- FindVariableFeatures(object = seurat, selection.method = ?, nfeatures = ?) ### Task: ?FindVariableFeatures into the console to read about different selection methods seurat &lt;- FindVariableFeatures(object = seurat, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(seurat), 10) We can see the Seurat object slots have updated for the FindVariableFetures section. Let’s use the slot to see how many variable genes we found. str(seurat) length(x = seurat@assays$RNA@var.features) Task: how does changing the parameters for find variable genes function changes the number of the found genes? Play with the parameters - what makes the function find more variable genes? less? seurat &lt;- FindVariableFeatures(object = seurat, selection.method = &quot;vst&quot;, nfeatures = 2000, mean.function = ExpMean, dispersion.function = LogVMR, num.bin = 40, mean.cutoff = c(0.0125, 1), dispersion.cutoff = c(0, 0.5)) ## Check number of variable genes length(seurat@assays$RNA@var.features) seurat &lt;- FindVariableFeatures(object = seurat, selection.method = &quot;vst&quot;, nfeatures = 2000, mean.function = ExpMean, dispersion.function = LogVMR, num.bin = 10, mean.cutoff = c(0.0125, 1), dispersion.cutoff = c(0, 0.5)) ## Check number of variable genes length(seurat@assays$RNA@var.features) seurat &lt;- FindVariableFeatures(object = seurat, selection.method = ??, nfeatures = 2000, mean.function = ExpMean, dispersion.function = LogVMR, num.bin = ??, mean.cutoff = c(??, ??), dispersion.cutoff = c(??, ??)) ## Check number of variable genes length(seurat@assays$RNA@var.features) seurat &lt;- FindVariableFeatures(object = seurat, selection.method = ??, nfeatures = 2000, mean.function = ExpMean, dispersion.function = LogVMR, num.bin = ??, mean.cutoff = c(??, ??), dispersion.cutoff = c(??, ??)) ## Check number of variable genes length(seurat@assays$RNA@var.features) seurat &lt;- FindVariableFeatures() ## Check number of variable genes length(seurat@assays$RNA@var.features) # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(seurat) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) ## When using repel, set xnudge and ynudge to 0 for optimal results ## CombinePlots(plots = list(plot1, plot2)) plot2 4.8 Gene set expression across cells Sometimes we want to ask what is the expression of a set of a genes across cells. This set of genes may make up a gene expression program we are interested in. Another benefit at looking at gene sets is it reduces the effects of drop outs. Below, we look at genes involved in: T cells, the cell cycle and the stress signature upon cell dissociation. We calculate these genes average expression levels on the single cell level, while controlling for technical effects. # Read in a list of cell cycle markers, from Tirosh et al, 2015. # We can segregate this list into markers of G2/M phase and markers of S phase. s.genes &lt;- Seurat::cc.genes$s.genes s.genes &lt;- s.genes[s.genes %in% rownames(seurat)] # genes in dataset g2m.genes &lt;- Seurat::cc.genes$g2m.genes g2m.genes &lt;- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset seurat &lt;- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE) Task: Use markers for dissociation to calculate dissociation score # Genes upregulated during dissociation of tissue into single cells. genes.dissoc &lt;- c(&quot;ATF3&quot;, &quot;BTG2&quot;, &quot;CEBPB&quot;, &quot;CEBPD&quot;, &quot;CXCL3&quot;, &quot;CXCL2&quot;, &quot;CXCL1&quot;, &quot;DNAJA1&quot;, &quot;DNAJB1&quot;, &quot;DUSP1&quot;, &quot;EGR1&quot;, &quot;FOS&quot;, &quot;FOSB&quot;, &quot;HSP90AA1&quot;, &quot;HSP90AB1&quot;, &quot;HSPA1A&quot;, &quot;HSPA1B&quot;, &quot;HSPA1A&quot;, &quot;HSPA1B&quot;, &quot;HSPA8&quot;, &quot;HSPB1&quot;, &quot;HSPE1&quot;, &quot;HSPH1&quot;, &quot;ID3&quot;, &quot;IER2&quot;, &quot;JUN&quot;, &quot;JUNB&quot;, &quot;JUND&quot;, &quot;MT1X&quot;, &quot;NFKBIA&quot;, &quot;NR4A1&quot;, &quot;PPP1R15A&quot;, &quot;SOCS3&quot;, &quot;ZFP36&quot;) #### seurat &lt;- ?(?, genes.list = list(?), ctrl.size = 20, enrich.name = &quot;genes_dissoc&quot;) seurat &lt;- AddModuleScore(seurat, features = list(genes.dissoc), ctrl.size = 20, enrich.name = &quot;genes_dissoc&quot;) Task: - Plot the correlation between number of genes and S score. - How do we know the name of these scores in the seurat meta data? ### GenePlot(seurat, &quot;S.Score&quot;, &quot;nGene&quot;) FeatureScatter(seurat, &quot;S.Score&quot;, &quot;nFeature_RNA&quot;) Bonus: Can you cluster the data based on the variable genes alone? Congratulations! You can identify and visualize cell subsets and the marker genes that describe these cell subsets. This is a very powerful analysis pattern often seen in publications. Well done! "],
["identifying-cell-populations-1.html", "5 Identifying Cell Populations 5.1 Google Slides", " 5 Identifying Cell Populations 5.1 Google Slides "],
["feature-selection-and-cluster-analysis-1.html", "6 Feature Selection and Cluster Analysis 6.1 Abstract 6.2 Seurat Tutorial Redo 6.3 Feature Selection 6.4 Other Options For Analysis", " 6 Feature Selection and Cluster Analysis 6.1 Abstract Many methods have been used to determine differential gene expression from single-cell RNA (scRNA)-seq data. We evaluated 36 approaches using experimental and synthetic data and found considerable differences in the number and characteristics of the genes that are called differentially expressed. Prefiltering of lowly expressed genes has important effects, particularly for some of the methods developed for bulk RNA-seq data analysis. However, we found that bulk RNA-seq analysis methods do not generally perform worse than those developed specifically for scRNA-seq. We also present conquer, a repository of consistently processed, analysis-ready public scRNA-seq data sets that is aimed at simplifying method evaluation and reanalysis of published results. Each data set provides abundance estimates for both genes and transcripts, as well as quality control and exploratory analysis reports. (???) Cells are the basic building blocks of organisms and each cell is unique. Single-cell RNA sequencing has emerged as an indispensable tool to dissect the cellular heterogeneity and decompose tissues into cell types and/or cell states, which offers enormous potential for de novo discovery. Single-cell transcriptomic atlases provide unprecedented resolution to reveal complex cellular events and deepen our understanding of biological systems. In this review, we summarize and compare single-cell RNA sequencing technologies, that were developed since 2009, to facilitate a well-informed choice of method. The applications of these methods in different biological contexts are also discussed. We anticipate an ever-increasing role of single-cell RNA sequencing in biology with further improvement in providing spatial information and coupling to other cellular modalities. In the future, such biological findings will greatly benefit medical research. (???) 6.2 Seurat Tutorial Redo For this tutorial, we will be analyzing the a dataset of Peripheral Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. There are 2,700 single cells that were sequenced on the Illumina NextSeq 500. The raw data can be found here. mkdir /home/genomics/workshop_materials/scrna/pbmc3k wget https://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O /home/genomics/workshop_materials/scrna/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz &amp;&amp; \\ cd /home/genomics/workshop_materials/scrna/pbmc3k/ &amp;&amp; \\ tar -xzf pbmc3k_filtered_gene_bc_matrices.tar.gz Task: Check the dirname to directory where you saved your data knitr::opts_knit$set(progress=FALSE, verbose=FALSE) library(Seurat) library(dplyr) library(ggplot2) library(CountClust) ##dirname &lt;- &quot;/home/genomics/workshop_materials/scrna/&quot; dirname &lt;- &quot;/Users/kgosik/Documents/data/cellranger/&quot; counts_matrix_filename = paste0(dirname, &quot;pbmc3k/filtered_gene_bc_matrices/hg19/&quot;) counts &lt;- Read10X(data.dir = counts_matrix_filename) # Seurat function to read in 10x count data ### seurat&lt;-CreateSeuratObject(raw.data = counts, ? = 3, ? = 350, project = &quot;10X_NSCLC&quot;) seurat &lt;- CreateSeuratObject(counts = counts, min.cells = 3, min.features = 350, project = &quot;10X_PBMC&quot;) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing ## with dashes (&#39;-&#39;) 6.2.1 Preprocessing Steps This was all covered in the last Lab! # The number of genes and UMIs (nFeature_RNA nCount_RNA) are automatically calculated # for every object by Seurat. For non-UMI data, nCount_RNA represents the sum of # the non-normalized values within a cell We calculate the percentage of # mitochondrial genes here and store it in percent.mito using AddMetaData. # We use object@raw.data since this represents non-transformed and # non-log-normalized counts The % of UMI mapping to MT-genes is a common # scRNA-seq QC metric. seurat[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(object = seurat, pattern = &quot;^MT-&quot;) ##VlnPlot(object = seurat, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) # FeatureScatter is typically used to visualize gene-gene relationships, but can # be used for anything calculated by the object, i.e. columns in # object@meta.data, PC scores etc. Since there is a rare subset of cells # with an outlier level of high mitochondrial percentage and also low UMI # content, we filter these as well par(mfrow = c(1, 2)) FeatureScatter(object = seurat, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) FeatureScatter(object = seurat, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) # We filter out cells that have unique gene counts over 2,500 or less than # 200 Note that low.thresholds and high.thresholds are used to define a # &#39;gate&#39;. -Inf and Inf should be used if you don&#39;t want a lower or upper # threshold. # seurat &lt;- SubsetData(object = seurat, # subset.names = c(&quot;nFeature_RNA&quot;, &quot;percent.mt&quot;), # low.thresholds = c(200, -Inf), # high.thresholds = c(2500, 0.1)) seurat &lt;- subset(seurat, nFeature_RNA &lt; 2500) seurat &lt;- subset(seurat, nFeature_RNA &gt; 200) seuart &lt;- subset(seurat, percent.mt &lt; 10) seurat &lt;- NormalizeData(object = seurat, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) # Read in a list of cell cycle markers, from Tirosh et al, 2015. # We can segregate this list into markers of G2/M phase and markers of S phase. s.genes &lt;- Seurat::cc.genes$s.genes s.genes &lt;- s.genes[s.genes %in% rownames(seurat)] # genes in dataset g2m.genes &lt;- Seurat::cc.genes$g2m.genes g2m.genes &lt;- g2m.genes[g2m.genes %in% rownames(seurat)] # genes in dataset seurat &lt;- CellCycleScoring(object = seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE) seurat &lt;- FindVariableFeatures(object = seurat, mean.function = ExpMean, dispersion.function = LogVMR) 6.2.2 Start of Identifying Cell Types 6.2.2.1 Scaling This part is where you mean center the data, substract the mean. You also divide by the standard deviation to make everything to a ‘standard normal’, where the mean is zero and the standard deviation is 1. seurat &lt;- ScaleData(object = seurat, vars.to.regress = c(&quot;batch&quot;, &quot;percent.mt&quot;)) ## Regressing out batch, percent.mt ## Centering and scaling data matrix Task: Try Regressing Other Variables ## randomly making a batch id data.frame batch_ids &lt;- data.frame(barcode = rownames(seurat@meta.data), batch_id = sample(0:2, NROW(seurat@meta.data), replace = TRUE), stringsAsFactors = FALSE) row.names(batch_ids) &lt;- row.names(seurat@meta.data) seurat &lt;- AddMetaData(object = seurat, metadata = batch_ids, col.name = NULL) seurat &lt;- ScaleData(object = seurat, vars.to.regress = &#39;batch_id&#39;) 6.2.2.2 Perform linear dimensional reduction (PCA) This will run pca on the seurat &lt;- RunPCA(object = seurat, # features = seurat@assays$RNA@var.features, ndims.print = 1:5, nfeatures.print = 5) ## PC_ 1 ## Positive: MALAT1, LTB, IL32, IL7R, CD2 ## Negative: CST3, TYROBP, LST1, AIF1, FTL ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DRA ## Negative: NKG7, PRF1, GZMA, CST7, GZMB ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, CD74 ## Negative: IL7R, VIM, TMSB4X, S100A8, IL32 ## PC_ 4 ## Positive: TMSB10, MALAT1, LGALS2, S100A8, S100A9 ## Negative: PF4, PPBP, SDPR, HIST1H2AC, SPARC ## PC_ 5 ## Positive: GZMB, FGFBP2, NKG7, GNLY, CCL4 ## Negative: LTB, VIM, IL7R, AQP3, KIAA0101 6.2.2.3 Visualizing PCA in Different Ways DimPlot(seurat, reduction = &quot;pca&quot;) 6.2.2.4 Perform linear dimensional reduction (ICA) Task: Try running Independent Component Analysis. If you need help with the inputs try using the ?RunICA menu. seurat &lt;- RunICA() 6.2.2.5 Visualizing ICA in Different Ways DimPlot() # ProjectDim scores each gene in the dataset (including genes not included # in the PCA) based on their correlation with the calculated components. # Though we don&#39;t use this further here, it can be used to identify markers # that are strongly correlated with cellular heterogeneity, but may not have # passed through variable gene selection. The results of the projected PCA # can be explored by setting use.full=T in the functions above seurat &lt;- ProjectDim(object = seurat, reduction = &quot;pca&quot;) ## PC_ 1 ## Positive: MALAT1, LTB, IL32, IL7R, CD2, ACAP1, STK17A, CTSW, CD247, CCL5 ## GIMAP5, AQP3, GZMA, CST7, TRAF3IP3, GZMK, MAL, HOPX, MYC, ETS1 ## Negative: CST3, TYROBP, LST1, AIF1, FTL, FTH1, FCN1, LYZ, S100A9, TYMP ## FCER1G, CFD, LGALS1, LGALS2, S100A8, CTSS, SERPINA1, SPI1, IFITM3, PSAP ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DRA, HLA-DQB1, LINC00926, CD79B, HLA-DRB1, CD74 ## HLA-DPB1, HLA-DMA, HLA-DQA2, HLA-DRB5, HLA-DPA1, HLA-DMB, HVCN1, FCRLA, LTB, BLNK ## Negative: NKG7, PRF1, GZMA, CST7, GZMB, FGFBP2, CTSW, GNLY, SPON2, GZMH ## CCL4, CCL5, FCGR3A, CD247, CLIC3, XCL2, AKR1C3, SRGN, HOPX, TTC38 ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, CD74, MS4A1, HLA-DPB1, HLA-DPA1, HLA-DRB1, HLA-DQA2 ## HLA-DRA, HLA-DRB5, TCL1A, LINC00926, HLA-DMA, HLA-DMB, HVCN1, FCRLA, KIAA0125, IRF8 ## Negative: IL7R, VIM, TMSB4X, S100A8, IL32, S100A6, S100A4, FYB, S100A9, MAL ## AQP3, RBP7, CD2, CD14, S100A10, LGALS2, S100A12, GIMAP4, NGFRAP1, ANXA1 ## PC_ 4 ## Positive: TMSB10, MALAT1, LGALS2, S100A8, S100A9, CD14, FCN1, LYZ, MS4A6A, S100A4 ## CCL3, TYROBP, S100A6, ALDH2, GSTP1, FOLR3, RBP7, S100A10, S100A12, IFI6 ## Negative: PF4, PPBP, SDPR, HIST1H2AC, SPARC, NRGN, GNG11, TSC22D1, RGS18, ACRBP ## TUBB1, MMD, ITGA2B, PTCRA, GP9, TMEM40, CMTM5, CA2, CLU, MAP3K7CL ## PC_ 5 ## Positive: GZMB, FGFBP2, NKG7, GNLY, CCL4, PRF1, CST7, SPON2, GZMA, XCL2 ## GZMH, CLIC3, CTSW, AKR1C3, TTC38, XCL1, CCL5, IGFBP7, S100A8, CCL3 ## Negative: LTB, VIM, IL7R, AQP3, KIAA0101, PPA1, TYMS, LDHA, ZWINT, HN1 ## MAL, ANXA5, CYTIP, CORO1B, IL32, CD2, TUBA1B, RRM2, PTGES3, TRADD 6.2.2.6 Genes by PCs DimHeatmap(object = seurat, dims = 1:6, cells = 50, reduction = &quot;pca&quot;, balanced = TRUE) Check other PCs to plot Task: Check other PCs DimHeatmap() seurat &lt;- JackStraw(object = seurat, reduction = &quot;pca&quot;) seurat &lt;- ScoreJackStraw(seurat, dims = 1:20) JackStrawPlot(seurat, dims = 1:15) ElbowPlot(object = seurat, ndims = 10, reduction = &quot;pca&quot;) # save.SNN = T saves the SNN so that the clustering algorithm can be rerun # using the same graph but with a different resolution value (see docs for # full details) set.seed(2020) seurat &lt;- FindNeighbors(object = seurat, dims = 1:10) ## Computing nearest neighbor graph ## Computing SNN seurat &lt;- FindClusters(object = seurat, reduction = &quot;pca&quot;, dims = 1:10, resolution = 0.5, random.seed = 2020) ## Warning: The following arguments are not used: reduction, dims ## Warning: The following arguments are not used: reduction, dims ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2655 ## Number of edges: 97412 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8712 ## Number of communities: 8 ## Elapsed time: 0 seconds 6.2.3 Run non-linear dimensional reduction (UMAP/tSNE) Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we suggest using the same PCs as input to the clustering analysis. set.seed(2020) seurat &lt;- RunTSNE(seurat, reduction.use = &quot;pca&quot;, dims.use = 1:10, perplexity=10) # note that you can set do.label=T to help label individual clusters DimPlot(object = seurat, reduction = &quot;tsne&quot;) Task: Try using UMAP for the non-linear dimension reduction technique (hint: ?RunUMAP) set.seed(2020) seurat &lt;- RunUMAP() # note that you can set label=TRUE to help label individual clusters DimPlot() 6.2.3.1 Finding differentially expressed features (cluster biomarkers) Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells. The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, max.cells.per.ident can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top. # find all markers of cluster 1 using default parameters cluster1.markers &lt;- FindMarkers(object = seurat, ident.1 = 1, min.pct = 0.25) head(cluster1.markers) ## p_val avg_logFC pct.1 pct.2 p_val_adj ## LTB 2.398388e-95 0.8846283 0.982 0.643 3.285072e-91 ## IL32 1.664226e-89 0.7966387 0.944 0.470 2.279490e-85 ## LDHB 3.561648e-80 0.7142016 0.966 0.610 4.878389e-76 ## IL7R 1.407429e-75 0.8335062 0.766 0.324 1.927756e-71 ## CD3D 1.112564e-71 0.6199745 0.915 0.435 1.523880e-67 ## AQP3 4.862610e-66 0.8776478 0.431 0.107 6.660317e-62 Task: Try tuning different parameters. How does that affect results? # find all markers distinguishing cluster 5 from clusters 0 and 1 cluster5.markers &lt;- FindMarkers(object = seurat, ident.1 = 5, ident.2 = c(0, 1), min.pct = ?? test.use = ??, only.pos = ??) head(cluster5.markers) cluster3.markers &lt;- FindMarkers(object = seurat, ident.1 = 3, thresh.use = 0.25, test.use = &quot;roc&quot;, only.pos = TRUE) ## Warning: The following arguments are not used: thresh.use head(cluster3.markers) ## myAUC avg_diff power pct.1 pct.2 ## CD74 0.984 2.029721 0.968 1.000 0.824 ## CD79A 0.966 2.968324 0.932 0.938 0.043 ## HLA-DRA 0.961 1.917675 0.922 1.000 0.492 ## CD79B 0.949 2.394172 0.898 0.927 0.145 ## HLA-DPB1 0.934 1.635536 0.868 0.988 0.447 ## MS4A1 0.925 2.344449 0.850 0.865 0.053 VlnPlot(object = seurat, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) # you can plot raw UMI counts as well VlnPlot(object = seurat, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), log = TRUE) # find markers for every cluster compared to all remaining cells, report # only the positive ones pbmc.markers &lt;- FindAllMarkers(object = seurat, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(2, avg_logFC) ## # A tibble: 16 x 7 ## # Groups: cluster [8] ## p_val avg_logFC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1.31e- 92 0.984 0.458 0.108 1.79e- 88 0 CCR7 ## 2 1.08e- 49 0.747 0.345 0.108 1.48e- 45 0 PRKCQ-AS1 ## 3 2.40e- 95 0.885 0.982 0.643 3.29e- 91 1 LTB ## 4 4.86e- 66 0.878 0.431 0.107 6.66e- 62 1 AQP3 ## 5 0. 3.84 0.996 0.217 0. 2 S100A9 ## 6 0. 3.77 0.971 0.123 0. 2 S100A8 ## 7 0. 2.97 0.938 0.043 0. 3 CD79A ## 8 4.00e-276 2.50 0.63 0.022 5.48e-272 3 TCL1A ## 9 1.16e-196 2.12 0.964 0.237 1.59e-192 4 CCL5 ## 10 2.16e-187 2.13 0.617 0.056 2.96e-183 4 GZMK ## 11 6.15e-171 2.26 0.929 0.137 8.43e-167 5 FCGR3A ## 12 4.31e-118 2.06 0.964 0.314 5.90e-114 5 LST1 ## 13 6.72e-267 3.35 0.961 0.07 9.20e-263 6 GZMB ## 14 1.53e-175 3.42 0.935 0.135 2.10e-171 6 GNLY ## 15 9.11e-253 2.68 0.829 0.01 1.25e-248 7 FCER1A ## 16 6.56e- 23 1.96 1 0.51 8.98e- 19 7 HLA-DPB1 FeaturePlot(object = seurat, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot;), cols = c(&quot;grey&quot;, &quot;blue&quot;), reduction = &quot;tsne&quot;) top10 &lt;- pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(10, avg_logFC) # setting slim.col.label to TRUE will print just the cluster IDS instead of # every cell name DoHeatmap(object = seurat, features = top10$gene, label = TRUE) ## Warning in DoHeatmap(object = seurat, features = top10$gene, ## label = TRUE): The following features were omitted as they ## were not found in the scale.data slot for the RNA assay: RHOC, ## RP11-290F20.3, GZMM, CD8A, VPREB3, CD40LG, CD7, PIK3IP1, CD3E, ## NOSIP, LEF1, PRKCQ-AS1, CD3D, LDHB, CCR7, RPS3A new.cluster.ids &lt;- c(&quot;Memory CD4 T&quot;, &quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Mk&quot;) names(x = new.cluster.ids) &lt;- levels(x = seurat) seurat &lt;- RenameIdents(object = seurat, new.cluster.ids) ## Warning: Cannot find identity NA DimPlot(object = seurat, reduction = &#39;tsne&#39;, label = TRUE, pt.size = 0.5) + NoLegend() 6.2.3.2 Further subdivisions within cell types If you perturb some of our parameter choices above (for example, setting resolution=0.8 or changing the number of PCs), you might see the CD4 T cells subdivide into two groups. You can explore this subdivision to find markers separating the two T cell subsets. However, before reclustering (which will overwrite object@ident), we can stash our renamed identities to be easily recovered later. # First lets stash our identities for later seurat[[&quot;ClusterNames_0.6&quot;]] &lt;- Idents(object = seurat) # Note that if you set save.snn=T above, you don&#39;t need to recalculate the # SNN, and can simply put: pbmc &lt;- FindClusters(pbmc,resolution = 0.8) seurat &lt;- FindClusters(object = seurat, reduction = &quot;pca&quot;, dims = 1:10, resolution = 0.8) ## Warning: The following arguments are not used: reduction, dims ## Warning: The following arguments are not used: reduction, dims ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2655 ## Number of edges: 97412 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8274 ## Number of communities: 10 ## Elapsed time: 0 seconds set.seed(2020) ## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type ## = reduction.type, : Build parameters exactly match those of already ## computed and stored SNN. To force recalculation, set force.recalc to TRUE. # Demonstration of how to plot two tSNE plots side by side, and how to color # points based on different criteria plot1 &lt;- DimPlot(object = seurat, reduction= &quot;tsne&quot;, label = TRUE) + NoLegend() plot2 &lt;- DimPlot(object = seurat, reduction = &quot;tsne&quot;, group.by = &quot;ClusterNames_0.6&quot;, label = TRUE) + NoLegend() CombinePlots(list(plot1, plot2)) # Find discriminating markers tcell.markers &lt;- FindMarkers(object = seurat, ident.1 = 0, ident.2 = 1) # Most of the markers tend to be expressed in C1 (i.e. S100A4). However, we # can see that CCR7 is upregulated in C0, strongly indicating that we can # differentiate memory from naive CD4 cells. cols demarcates the color # palette from low to high expression FeaturePlot(object = seurat, features = c(&quot;S100A4&quot;, &quot;CCR7&quot;), cols = c(&quot;green&quot;, &quot;blue&quot;)) 6.3 Feature Selection 6.3.1 Differential Expression Analysis 6.3.1.1 Differential Expression Tests One of the most commonly performed tasks for RNA-seq data is differential gene expression (DE) analysis. Although well-established tools exist for such analysis in bulk RNA-seq data, methods for scRNA-seq data are just emerging. Given the special characteristics of scRNA-seq data, including generally low library sizes, high noise levels and a large fraction of so-called ‘dropout’ events, it is unclear whether DE methods that have been developed for bulk RNA-seq are suitable also for scRNA-seq. Check the help page out for the FindMarkers function by using ?FindMarkers ## Differential expression using t-test FindMarkers(object = seurat, ident.1 = 0, ident.2 = 1, test.use = &quot;t&quot;) Task: Try to use different test for diffential expression analysis (hint: ?FindMarkers) ## Use the help function and run other tests. Do they find similar markers? FindMarkers(object = seurat, ident.1 = 0, ident.2 = 1, test.use = ??) 6.3.2 Check Clusters How do we test the cell types identified? How do we know how reliable they are? Use Classifier to predict cell cluster. See how it predicts using hold out data. reference # Assign the test object a three level attribute groups &lt;- sample(c(&quot;train&quot;, &quot;test&quot;), size = NROW(seurat@meta.data), replace = TRUE, prob = c(0.8, 0.2)) names(groups) &lt;- colnames(seurat) seurat &lt;- AddMetaData(object = seurat, metadata = groups, col.name = &quot;group&quot;) # Find Anchors seurat.list &lt;- SplitObject(seurat, split.by = &quot;group&quot;) seurat.anchors &lt;- FindIntegrationAnchors(object.list = seurat.list, dims = 1:30) ## Computing 2000 integration features ## Scaling features for provided objects ## Finding all pairwise anchors ## Running CCA ## Merging objects ## Finding neighborhoods ## Finding anchors ## Found 2597 anchors ## Filtering anchors ## Retained 1400 anchors ## Extracting within-dataset neighbors seurat.integrated &lt;- IntegrateData(anchorset = seurat.anchors, dims = 1:30) ## Merging dataset 1 into 2 ## Extracting anchors for merged samples ## Finding integration vectors ## Finding integration vector weights ## Integrating data ## Warning: Adding a command log without an assay associated with ## it seurat.query &lt;- seurat.list[[&quot;train&quot;]] seurat.anchors &lt;- FindTransferAnchors(reference = seurat.integrated, query = seurat.query, dims = 1:30) ## Performing PCA on the provided reference using 2000 features as input. ## Projecting PCA ## Finding neighborhoods ## Finding anchors ## Found 6141 anchors ## Filtering anchors ## Retained 4729 anchors ## Extracting within-dataset neighbors predictions &lt;- TransferData(anchorset = seurat.anchors, refdata = seurat.integrated$ClusterNames_0.6, dims = 1:30) ## Finding integration vectors ## Finding integration vector weights ## Predicting cell labels seurat.query &lt;- AddMetaData(seurat.query, metadata = predictions) table(seurat.query@meta.data$ClusterNames_0.6, seurat.query@meta.data$predicted.id) ## ## B CD14+ Mono CD8 T DC FCGR3A+ Mono ## Memory CD4 T 0 0 2 0 1 ## Naive CD4 T 0 0 0 0 0 ## CD14+ Mono 0 365 0 0 1 ## B 268 0 0 0 0 ## CD8 T 0 0 225 0 0 ## FCGR3A+ Mono 0 8 0 0 130 ## NK 1 0 7 0 0 ## DC 0 1 0 28 0 ## ## Memory CD4 T Naive CD4 T NK ## Memory CD4 T 542 11 0 ## Naive CD4 T 53 334 0 ## CD14+ Mono 0 0 0 ## B 0 0 0 ## CD8 T 12 7 0 ## FCGR3A+ Mono 0 0 0 ## NK 0 0 122 ## DC 0 0 0 6.3.3 View Entire Object Structure Notice all the slots and elements added to the object. str(seurat) ## Formal class &#39;Seurat&#39; [package &quot;Seurat&quot;] with 12 slots ## ..@ assays :List of 1 ## .. ..$ RNA:Formal class &#39;Assay&#39; [package &quot;Seurat&quot;] with 8 slots ## .. .. .. ..@ counts :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2269052] 29 73 80 147 162 183 185 226 228 229 ... ## .. .. .. .. .. ..@ p : int [1:2656] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13697 2655 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13697] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. .. ..@ x : num [1:2269052] 1 1 2 1 1 1 1 41 1 1 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ data :Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots ## .. .. .. .. .. ..@ i : int [1:2269052] 29 73 80 147 162 183 185 226 228 229 ... ## .. .. .. .. .. ..@ p : int [1:2656] 0 779 2131 3260 4220 4741 5522 6304 7094 7626 ... ## .. .. .. .. .. ..@ Dim : int [1:2] 13697 2655 ## .. .. .. .. .. ..@ Dimnames:List of 2 ## .. .. .. .. .. .. ..$ : chr [1:13697] &quot;AL627309.1&quot; &quot;AP006222.2&quot; &quot;RP11-206L10.2&quot; &quot;RP11-206L10.9&quot; ... ## .. .. .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. .. ..@ x : num [1:2269052] 1.64 1.64 2.23 1.64 1.64 ... ## .. .. .. .. .. ..@ factors : list() ## .. .. .. ..@ scale.data : num [1:2000, 1:2655] -0.8423 -0.2675 1.5408 -0.0487 -0.4588 ... ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2000] &quot;ISG15&quot; &quot;CPSF3L&quot; &quot;MRPL20&quot; &quot;ATAD3C&quot; ... ## .. .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. ..@ key : chr &quot;rna_&quot; ## .. .. .. ..@ assay.orig : NULL ## .. .. .. ..@ var.features : chr [1:2000] &quot;S100A9&quot; &quot;LYZ&quot; &quot;IGLL5&quot; &quot;GNLY&quot; ... ## .. .. .. ..@ meta.features:&#39;data.frame&#39;: 13697 obs. of 5 variables: ## .. .. .. .. ..$ vst.mean : num [1:13697] 0.00339 0.00113 0.00188 0.00113 0.00678 ... ## .. .. .. .. ..$ vst.variance : num [1:13697] 0.00338 0.00113 0.00188 0.00113 0.00674 ... ## .. .. .. .. ..$ vst.variance.expected : num [1:13697] 0.00364 0.00113 0.00196 0.00113 0.00748 ... ## .. .. .. .. ..$ vst.variance.standardized: num [1:13697] 0.928 0.999 0.961 0.999 0.901 ... ## .. .. .. .. ..$ vst.variable : logi [1:13697] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. .. .. ..@ misc : NULL ## ..@ meta.data :&#39;data.frame&#39;: 2655 obs. of 13 variables: ## .. ..$ orig.ident : Factor w/ 1 level &quot;10X_PBMC&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ nCount_RNA : num [1:2655] 2419 4903 3147 2639 980 ... ## .. ..$ nFeature_RNA : int [1:2655] 779 1352 1129 960 521 781 782 790 532 550 ... ## .. ..$ percent.mt : num [1:2655] 3.02 3.79 0.89 1.74 1.22 ... ## .. ..$ S.Score : num [1:2655] 0.0825 -0.0276 -0.0124 0.0405 -0.0273 ... ## .. ..$ G2M.Score : num [1:2655] -0.0324 -0.0517 0.0833 0.0155 0.0334 ... ## .. ..$ Phase : Factor w/ 3 levels &quot;G1&quot;,&quot;G2M&quot;,&quot;S&quot;: 3 1 2 3 2 1 1 2 1 3 ... ## .. ..$ old.ident : Factor w/ 1 level &quot;10X_PBMC&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## .. ..$ RNA_snn_res.0.5 : Factor w/ 8 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 2 4 2 6 7 2 5 5 1 6 ... ## .. ..$ seurat_clusters : Factor w/ 10 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 3 1 8 9 1 5 5 2 8 ... ## .. ..$ ClusterNames_0.6: Factor w/ 8 levels &quot;Memory CD4 T&quot;,..: 2 4 2 6 7 2 5 5 1 6 ... ## .. ..$ RNA_snn_res.0.8 : Factor w/ 10 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 3 1 8 9 1 5 5 2 8 ... ## .. ..$ group : chr [1:2655] &quot;test&quot; &quot;test&quot; &quot;train&quot; &quot;train&quot; ... ## ..@ active.assay: chr &quot;RNA&quot; ## ..@ active.ident: Factor w/ 10 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 1 3 1 8 9 1 5 5 2 8 ... ## .. ..- attr(*, &quot;names&quot;)= chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## ..@ graphs :List of 2 ## .. ..$ RNA_nn :Formal class &#39;Graph&#39; [package &quot;Seurat&quot;] with 7 slots ## .. .. .. ..@ assay.used: chr &quot;RNA&quot; ## .. .. .. ..@ i : int [1:53100] 0 102 167 417 623 1207 1260 1835 2148 2155 ... ## .. .. .. ..@ p : int [1:2656] 0 12 32 51 75 86 90 126 153 164 ... ## .. .. .. ..@ Dim : int [1:2] 2655 2655 ## .. .. .. ..@ Dimnames :List of 2 ## .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. ..@ x : num [1:53100] 1 1 1 1 1 1 1 1 1 1 ... ## .. .. .. ..@ factors : list() ## .. ..$ RNA_snn:Formal class &#39;Graph&#39; [package &quot;Seurat&quot;] with 7 slots ## .. .. .. ..@ assay.used: chr &quot;RNA&quot; ## .. .. .. ..@ i : int [1:197479] 0 84 102 167 205 383 417 457 480 489 ... ## .. .. .. ..@ p : int [1:2656] 0 62 115 168 225 270 319 403 479 512 ... ## .. .. .. ..@ Dim : int [1:2] 2655 2655 ## .. .. .. ..@ Dimnames :List of 2 ## .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. ..@ x : num [1:197479] 1 0.0811 0.1765 0.0811 0.1111 ... ## .. .. .. ..@ factors : list() ## ..@ neighbors : list() ## ..@ reductions :List of 2 ## .. ..$ pca :Formal class &#39;DimReduc&#39; [package &quot;Seurat&quot;] with 9 slots ## .. .. .. ..@ cell.embeddings : num [1:2655, 1:50] 5.28 1.22 1.89 -12.14 2.44 ... ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. .. ..$ : chr [1:50] &quot;PC_1&quot; &quot;PC_2&quot; &quot;PC_3&quot; &quot;PC_4&quot; ... ## .. .. .. ..@ feature.loadings : num [1:2000, 1:50] -0.11749 -0.11826 0.00861 0.01508 -0.0136 ... ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2000] &quot;S100A9&quot; &quot;LYZ&quot; &quot;IGLL5&quot; &quot;GNLY&quot; ... ## .. .. .. .. .. ..$ : chr [1:50] &quot;PC_1&quot; &quot;PC_2&quot; &quot;PC_3&quot; &quot;PC_4&quot; ... ## .. .. .. ..@ feature.loadings.projected: num [1:2000, 1:50] -7900 388 -1755 248 -1734 ... ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2000] &quot;ISG15&quot; &quot;CPSF3L&quot; &quot;MRPL20&quot; &quot;ATAD3C&quot; ... ## .. .. .. .. .. ..$ : chr [1:50] &quot;PC_1&quot; &quot;PC_2&quot; &quot;PC_3&quot; &quot;PC_4&quot; ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ global : logi FALSE ## .. .. .. ..@ stdev : num [1:50] 6.96 4.45 3.77 3.35 3.15 ... ## .. .. .. ..@ key : chr &quot;PC_&quot; ## .. .. .. ..@ jackstraw :Formal class &#39;JackStrawData&#39; [package &quot;Seurat&quot;] with 4 slots ## .. .. .. .. .. ..@ empirical.p.values : num[0 , 0 ] ## .. .. .. .. .. ..@ fake.reduction.scores : num[0 , 0 ] ## .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] ## .. .. .. .. .. ..@ overall.p.values : num[0 , 0 ] ## .. .. .. ..@ misc :List of 1 ## .. .. .. .. ..$ total.variance: num 1721 ## .. ..$ tsne:Formal class &#39;DimReduc&#39; [package &quot;Seurat&quot;] with 9 slots ## .. .. .. ..@ cell.embeddings : num [1:2655, 1:2] 2.08 37.16 15.8 -10.98 22.77 ... ## .. .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. .. ..$ : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. .. ..$ : chr [1:2] &quot;tSNE_1&quot; &quot;tSNE_2&quot; ## .. .. .. ..@ feature.loadings : num[0 , 0 ] ## .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ global : logi TRUE ## .. .. .. ..@ stdev : num(0) ## .. .. .. ..@ key : chr &quot;tSNE_&quot; ## .. .. .. ..@ jackstraw :Formal class &#39;JackStrawData&#39; [package &quot;Seurat&quot;] with 4 slots ## .. .. .. .. .. ..@ empirical.p.values : num[0 , 0 ] ## .. .. .. .. .. ..@ fake.reduction.scores : num[0 , 0 ] ## .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] ## .. .. .. .. .. ..@ overall.p.values : num[0 , 0 ] ## .. .. .. ..@ misc : list() ## ..@ project.name: chr &quot;10X_PBMC&quot; ## ..@ misc : list() ## ..@ version :Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. ..$ : int [1:3] 3 1 2 ## ..@ commands :List of 8 ## .. ..$ NormalizeData.RNA :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;NormalizeData.RNA&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr [1:2] &quot;NormalizeData(object = seurat, normalization.method = \\&quot;LogNormalize\\&quot;, &quot; &quot; scale.factor = 10000)&quot; ## .. .. .. ..@ params :List of 5 ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ normalization.method: chr &quot;LogNormalize&quot; ## .. .. .. .. ..$ scale.factor : num 10000 ## .. .. .. .. ..$ margin : num 1 ## .. .. .. .. ..$ verbose : logi TRUE ## .. ..$ FindVariableFeatures.RNA:Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;FindVariableFeatures.RNA&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr [1:2] &quot;FindVariableFeatures(object = seurat, mean.function = ExpMean, &quot; &quot; dispersion.function = LogVMR)&quot; ## .. .. .. ..@ params :List of 12 ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ selection.method : chr &quot;vst&quot; ## .. .. .. .. ..$ loess.span : num 0.3 ## .. .. .. .. ..$ clip.max : chr &quot;auto&quot; ## .. .. .. .. ..$ mean.function :function (x, ...) ## .. .. .. .. ..$ dispersion.function:function (x, ...) ## .. .. .. .. ..$ num.bin : num 20 ## .. .. .. .. ..$ binning.method : chr &quot;equal_width&quot; ## .. .. .. .. ..$ nfeatures : num 2000 ## .. .. .. .. ..$ mean.cutoff : num [1:2] 0.1 8 ## .. .. .. .. ..$ dispersion.cutoff : num [1:2] 1 Inf ## .. .. .. .. ..$ verbose : logi TRUE ## .. ..$ ScaleData.RNA :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;ScaleData.RNA&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr [1:2] &quot;ScaleData(object = seurat, vars.to.regress = c(\\&quot;batch\\&quot;, &quot; &quot; \\&quot;percent.mt\\&quot;))&quot; ## .. .. .. ..@ params :List of 11 ## .. .. .. .. ..$ features : chr [1:2000] &quot;S100A9&quot; &quot;LYZ&quot; &quot;IGLL5&quot; &quot;GNLY&quot; ... ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ vars.to.regress : chr [1:2] &quot;batch&quot; &quot;percent.mt&quot; ## .. .. .. .. ..$ model.use : chr &quot;linear&quot; ## .. .. .. .. ..$ use.umi : logi FALSE ## .. .. .. .. ..$ do.scale : logi TRUE ## .. .. .. .. ..$ do.center : logi TRUE ## .. .. .. .. ..$ scale.max : num 10 ## .. .. .. .. ..$ block.size : num 1000 ## .. .. .. .. ..$ min.cells.to.block: num 2655 ## .. .. .. .. ..$ verbose : logi TRUE ## .. ..$ RunPCA.RNA :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;RunPCA.RNA&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr &quot;RunPCA(object = seurat, ndims.print = 1:5, nfeatures.print = 5)&quot; ## .. .. .. ..@ params :List of 10 ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ npcs : num 50 ## .. .. .. .. ..$ rev.pca : logi FALSE ## .. .. .. .. ..$ weight.by.var : logi TRUE ## .. .. .. .. ..$ verbose : logi TRUE ## .. .. .. .. ..$ ndims.print : int [1:5] 1 2 3 4 5 ## .. .. .. .. ..$ nfeatures.print: num 5 ## .. .. .. .. ..$ reduction.name : chr &quot;pca&quot; ## .. .. .. .. ..$ reduction.key : chr &quot;PC_&quot; ## .. .. .. .. ..$ seed.use : num 42 ## .. ..$ ProjectDim.RNA.pca :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;ProjectDim.RNA.pca&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr &quot;ProjectDim(object = seurat, reduction = \\&quot;pca\\&quot;)&quot; ## .. .. .. ..@ params :List of 7 ## .. .. .. .. ..$ reduction : chr &quot;pca&quot; ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ dims.print : int [1:5] 1 2 3 4 5 ## .. .. .. .. ..$ nfeatures.print: num 20 ## .. .. .. .. ..$ overwrite : logi FALSE ## .. .. .. .. ..$ do.center : logi FALSE ## .. .. .. .. ..$ verbose : logi TRUE ## .. ..$ FindNeighbors.RNA.pca :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;FindNeighbors.RNA.pca&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr &quot;FindNeighbors(object = seurat, dims = 1:10)&quot; ## .. .. .. ..@ params :List of 13 ## .. .. .. .. ..$ reduction : chr &quot;pca&quot; ## .. .. .. .. ..$ dims : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. .. .. .. ..$ assay : chr &quot;RNA&quot; ## .. .. .. .. ..$ k.param : num 20 ## .. .. .. .. ..$ compute.SNN : logi TRUE ## .. .. .. .. ..$ prune.SNN : num 0.0667 ## .. .. .. .. ..$ nn.method : chr &quot;rann&quot; ## .. .. .. .. ..$ annoy.metric: chr &quot;euclidean&quot; ## .. .. .. .. ..$ nn.eps : num 0 ## .. .. .. .. ..$ verbose : logi TRUE ## .. .. .. .. ..$ force.recalc: logi FALSE ## .. .. .. .. ..$ do.plot : logi FALSE ## .. .. .. .. ..$ graph.name : chr [1:2] &quot;RNA_nn&quot; &quot;RNA_snn&quot; ## .. ..$ RunTSNE :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;RunTSNE&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr [1:2] &quot;RunTSNE(seurat, reduction.use = \\&quot;pca\\&quot;, dims.use = 1:10, &quot; &quot; perplexity = 10)&quot; ## .. .. .. ..@ params :List of 9 ## .. .. .. .. ..$ reduction : chr &quot;pca&quot; ## .. .. .. .. ..$ cells : chr [1:2655] &quot;AAACATACAACCAC&quot; &quot;AAACATTGAGCTAC&quot; &quot;AAACATTGATCAGC&quot; &quot;AAACCGTGCTTCCG&quot; ... ## .. .. .. .. ..$ dims : int [1:5] 1 2 3 4 5 ## .. .. .. .. ..$ seed.use : num 1 ## .. .. .. .. ..$ tsne.method : chr &quot;Rtsne&quot; ## .. .. .. .. ..$ add.iter : num 0 ## .. .. .. .. ..$ dim.embed : num 2 ## .. .. .. .. ..$ reduction.name: chr &quot;tsne&quot; ## .. .. .. .. ..$ reduction.key : chr &quot;tSNE_&quot; ## .. ..$ FindClusters :Formal class &#39;SeuratCommand&#39; [package &quot;Seurat&quot;] with 5 slots ## .. .. .. ..@ name : chr &quot;FindClusters&quot; ## .. .. .. ..@ time.stamp : POSIXct[1:1], format: ... ## .. .. .. ..@ assay.used : chr &quot;RNA&quot; ## .. .. .. ..@ call.string: chr [1:2] &quot;FindClusters(object = seurat, reduction = \\&quot;pca\\&quot;, dims = 1:10, &quot; &quot; resolution = 0.8)&quot; ## .. .. .. ..@ params :List of 10 ## .. .. .. .. ..$ graph.name : chr &quot;RNA_snn&quot; ## .. .. .. .. ..$ modularity.fxn : num 1 ## .. .. .. .. ..$ resolution : num 0.8 ## .. .. .. .. ..$ method : chr &quot;matrix&quot; ## .. .. .. .. ..$ algorithm : num 1 ## .. .. .. .. ..$ n.start : num 10 ## .. .. .. .. ..$ n.iter : num 10 ## .. .. .. .. ..$ random.seed : num 0 ## .. .. .. .. ..$ group.singletons: logi TRUE ## .. .. .. .. ..$ verbose : logi TRUE ## ..@ tools : list() 6.3.3.1 Probabilistic (LDA) Another type of clustering we can do is a fuzzy or probablistic clustering. This is where cells are not assigned to specifically only one cluster. They get assigned a score for how much the cells belong to each of the clusters (sometimes called topics). This can be helpful for when your dataset continuous processes and/or cellular states as opposed to distinct cell types. data(&quot;MouseDeng2014.FitGoM&quot;) names(MouseDeng2014.FitGoM) ## [1] &quot;clust_3&quot; &quot;clust_6&quot; omega &lt;- MouseDeng2014.FitGoM$clust_6$omega annotation &lt;- data.frame( sample_id = paste0(&quot;X&quot;, c(1:NROW(omega))), tissue_label = factor(rownames(omega), levels = rev(c(&quot;zy&quot;, &quot;early2cell&quot;, &quot;mid2cell&quot;, &quot;late2cell&quot;, &quot;4cell&quot;, &quot;8cell&quot;, &quot;16cell&quot;, &quot;earlyblast&quot;, &quot;midblast&quot;, &quot;lateblast&quot;))) ) rownames(omega) &lt;- annotation$sample_id; StructureGGplot(omega = omega, annotation = annotation, palette = RColorBrewer::brewer.pal(8, &quot;Accent&quot;), yaxis_label = &quot;Amplification batch&quot;, order_sample = TRUE, axis_tick = list(axis_ticks_length = .1, axis_ticks_lwd_y = .1, axis_ticks_lwd_x = .1, axis_label_size = 7, axis_label_face = &quot;bold&quot;)) set.seed(2020) ## Preprocessing Steps pbmc_small &lt;- NormalizeData(object = pbmc_small, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) pbmc_small &lt;- RunPCA(object = pbmc_small) ## Warning in irlba(A = t(x = object), nv = npcs, ...): You&#39;re ## computing too large a percentage of total singular values, use a ## standard svd instead. ## Warning in irlba(A = t(x = object), nv = npcs, ...): did not ## converge--results might be invalid!; try increasing work or ## maxit ## PC_ 1 ## Positive: SDPR, PF4, PPBP, TUBB1, CA2, TREML1, MYL9, PGRMC1, RUFY1, PARVB ## VDAC3, IGLL5, AKR1C3, CD1C, RP11-290F20.3, GNLY, S100A8, S100A9, HLA-DQA1, HLA-DPB1 ## Negative: HLA-DPB1, HLA-DQA1, S100A9, S100A8, GNLY, RP11-290F20.3, CD1C, AKR1C3, IGLL5, VDAC3 ## PARVB, RUFY1, PGRMC1, MYL9, TREML1, CA2, TUBB1, PPBP, PF4, SDPR ## PC_ 2 ## Positive: HLA-DPB1, HLA-DQA1, S100A8, S100A9, CD1C, RP11-290F20.3, PARVB, IGLL5, MYL9, SDPR ## PPBP, CA2, RUFY1, TREML1, PF4, TUBB1, PGRMC1, VDAC3, AKR1C3, GNLY ## Negative: GNLY, AKR1C3, VDAC3, PGRMC1, TUBB1, PF4, TREML1, RUFY1, CA2, PPBP ## SDPR, MYL9, IGLL5, PARVB, RP11-290F20.3, CD1C, S100A9, S100A8, HLA-DQA1, HLA-DPB1 ## PC_ 3 ## Positive: S100A9, S100A8, RP11-290F20.3, AKR1C3, PARVB, GNLY, PPBP, PGRMC1, MYL9, TUBB1 ## CA2, TREML1, SDPR, VDAC3, PF4, RUFY1, HLA-DPB1, IGLL5, CD1C, HLA-DQA1 ## Negative: HLA-DQA1, CD1C, IGLL5, HLA-DPB1, RUFY1, PF4, VDAC3, SDPR, TREML1, CA2 ## TUBB1, MYL9, PGRMC1, PPBP, GNLY, PARVB, AKR1C3, RP11-290F20.3, S100A8, S100A9 ## PC_ 4 ## Positive: IGLL5, RP11-290F20.3, VDAC3, PPBP, TUBB1, TREML1, PF4, CA2, PARVB, MYL9 ## SDPR, RUFY1, PGRMC1, S100A9, HLA-DQA1, HLA-DPB1, GNLY, S100A8, AKR1C3, CD1C ## Negative: CD1C, AKR1C3, S100A8, GNLY, HLA-DPB1, HLA-DQA1, S100A9, PGRMC1, RUFY1, SDPR ## MYL9, PARVB, CA2, PF4, TREML1, TUBB1, PPBP, VDAC3, RP11-290F20.3, IGLL5 ## PC_ 5 ## Positive: MYL9, PARVB, IGLL5, TREML1, AKR1C3, PGRMC1, HLA-DPB1, S100A9, TUBB1, PF4 ## SDPR, GNLY, PPBP, S100A8, CA2, HLA-DQA1, CD1C, RUFY1, RP11-290F20.3, VDAC3 ## Negative: VDAC3, RP11-290F20.3, RUFY1, CD1C, HLA-DQA1, CA2, S100A8, PPBP, GNLY, SDPR ## PF4, TUBB1, S100A9, HLA-DPB1, PGRMC1, AKR1C3, TREML1, IGLL5, PARVB, MYL9 pbmc_small &lt;- FindClusters(object = pbmc_small, reduction = &quot;pca&quot;, dims.use = 1:10, resolution = 1, print.output = 0) ## Warning: The following arguments are not used: reduction, ## dims.use, print.output ## Suggested parameter: dims instead of dims.use; verbose instead of print.output ## Warning: The following arguments are not used: reduction, ## dims.use, print.output ## Suggested parameter: dims instead of dims.use; verbose instead of print.output ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 80 ## Number of edges: 3124 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.1433 ## Number of communities: 3 ## Elapsed time: 0 seconds ## Warning: Adding a command log without an assay associated with ## it pbmc_counts &lt;- as.matrix(pbmc_small@assays$RNA@data) pbmc_meta &lt;- pbmc_small@meta.data gene_names &lt;- rownames(pbmc_counts) pbmc_FitGoM &lt;- FitGoM(t(pbmc_counts), K=4) ## options not specified: switching to default BIC, other choice is BF for Bayes factor ## Fitting a Grade of Membership model ## (Taddy M., AISTATS 2012, JMLR 22, ## http://proceedings.mlr.press/v22/taddy12/taddy12.pdf) ## ## Estimating on a 80 document collection. ## Fit and Bayes Factor Estimation for K = 4 ## log posterior increase: 1006, 69.7, 71, done. ## log BF( 4 ) = 5090.41 omega &lt;- data.frame(pbmc_FitGoM$fit$omega) annotation &lt;- data.frame(sample_id = rownames(omega), tissue_label = paste0(&quot;cluster&quot;, pbmc_small@active.ident)) colnames(omega) &lt;- paste0(&quot;topic&quot;, 1:4) rownames(omega) &lt;- annotation$sample_id; StructureGGplot(omega = omega, annotation = annotation, palette = RColorBrewer::brewer.pal(4, &quot;Dark2&quot;), yaxis_label = &quot;Cells&quot;, order_sample = TRUE, axis_tick = list(axis_ticks_length = .1, axis_ticks_lwd_y = .1, axis_ticks_lwd_x = .1, axis_label_size = 7, axis_label_face = &quot;bold&quot;)) # ## Add Topic Scores to Meta Data Part of the Seurat Object pbmc_small &lt;- AddMetaData(pbmc_small, omega) pbmc_small@meta.data %&gt;% group_by(RNA_snn_res.1) %&gt;% summarise(topic1 = mean(topic1), topic2 = mean(topic2), topic3 = mean(topic3), topic4 = mean(topic4)) ## # A tibble: 3 x 5 ## RNA_snn_res.1 topic1 topic2 topic3 topic4 ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0.281 0.290 0.221 0.207 ## 2 1 0.913 0.0253 0.0170 0.0450 ## 3 2 0.595 0.0663 0.194 0.145 ## ggplot object, you can add layers p1 &lt;- DimPlot(pbmc_small, reduction = &quot;tsne&quot;) + labs(title = &quot;Resolution 1&quot;) ## return ggplot object p1 p2 &lt;- FeaturePlot(object = pbmc_small, features = c(&quot;topic1&quot;, &quot;topic2&quot;, &quot;topic3&quot;, &quot;topic4&quot;), cols = c(&quot;grey&quot;, &quot;blue&quot;), reduction = &quot;tsne&quot;) ## return ggplot object p2 CombinePlots(list(p1, p2)) ## Warning: Graphs cannot be vertically aligned unless the axis ## parameter is set. Placing graphs unaligned. 6.3.3.2 Extract Top Feature theta_mat &lt;- pbmc_FitGoM$fit$theta top_features &lt;- ExtractTopFeatures(theta_mat, top_features=100, method=&quot;poisson&quot;, options=&quot;min&quot;) gene_list &lt;- do.call(rbind, lapply(1:dim(top_features$indices)[1], function(x) gene_names[top_features$indices[x,]])) We tabulate the top 5 genes for these 4 topics out_table &lt;- do.call(rbind, lapply(1:4, function(i) toString(gene_list[i,1:5]))) rownames(out_table) &lt;- paste(&quot;Topic&quot;, c(1:4)) out_table ## [,1] ## Topic 1 &quot;GRN, HLA-DMB, IFI30, LY86, PF4&quot; ## Topic 2 &quot;GNLY, GZMB, PRF1, GZMH, CCL4&quot; ## Topic 3 &quot;GZMK, HNRNPH1, SATB1, SIT1, CRBN&quot; ## Topic 4 &quot;PIK3IP1, TNFAIP8, THYN1, SP100, CCR7&quot; 6.3.4 Practice Visualizing/Embedding 6.3.4.1 tSNE Change the parameter settings for tSNE RunTSNE() 6.3.4.2 UMAP Change the parameter settings for UMAP RunUMAP() 6.4 Other Options For Analysis More Seurat Vignettes Single Cell Analysis Workshop Hemberg Lab Course SingleCellExperiment Scanpy Pegasus "],
["single-cell-resources.html", "7 Single Cell Resources 7.1 Comprehensive list of single-cell resources 7.2 Computational packages for single-cell analysis 7.3 eLife Commentary on the Human Cell Atlas 7.4 Online courses", " 7 Single Cell Resources 7.1 Comprehensive list of single-cell resources https://github.com/seandavi/awesome-single-cell 7.2 Computational packages for single-cell analysis http://bioconductor.org/packages/devel/workflows/html/simpleSingleCell.html https://satijalab.org/seurat/ https://scanpy.readthedocs.io/ 7.3 eLife Commentary on the Human Cell Atlas link - Nature Commentary on the Human Cell Atlas - https://www.nature.com/news/the-human-cell-atlas-from-vision-to-reality-1.22854 7.4 Online courses https://scrnaseq-course.cog.sanger.ac.uk/website/index.html https://broadinstitute.github.io/2019_scWorkshop/ https://github.com/SingleCellTranscriptomics https://r4ds.had.co.nz/ "],
["references.html", "References", " References "]
]
